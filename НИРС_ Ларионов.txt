Министерство образования и науки Российской Федерации
Федеральное государственное бюджетное образовательное 
учреждение высшего образования
Пермский национальный исследовательский политехнический университет (ПНИПУ)

Факультет: Электротехнический (ЭТФ)
Направление: 09.03.04 – Программная инженерия (ПИ)
Профиль: Разработка программно-информационных систем (РИСб)
Кафедра информационных технологий и автоматизированных систем (ИТАС)

Зав. кафедрой: д-р экон. наук, проф.
Файзрахманов Р.А.________________________
«_________»_______________________  2018 г.


ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА
на соискание академической степени бакалавра

на тему
«Разработка аппаратного и программного обеспечения системы управления исполнительными механизмами андроидного робота»



Студент:

Ларионов Александр Андреевич

(подпись, дата)

Группа:
РИС-14-1б

Состав ВКР:
Пояснительная записка на ____ стр.
Графический материал.
Электронный носитель с материалами ВКР.

Руководитель ВКР:

уч. степень, должность Фамилия И.О.


Консультант по предметной области:

уч. степень, должность Фамилия И.О.


Прохождение предзащиты:

канд. техн. наук, доцент 
Мурзакаев Р.Т.


Прохождение нормоконтроля:

ст. преподаватель Мехоношин А.С.


Прохождение проверки на объем заимствований:


ст. преподаватель Мехоношин А.С.

(подпись, дата)

Пермь — 2018
Министерство образования и науки Российской Федерации
Федеральное государственное бюджетное образовательное 
учреждение высшего образования
Пермский национальный исследовательский политехнический университет (ПНИПУ)

Факультет: Электротехнический (ЭТФ)
Направление: 09.03.04 – Программная инженерия (ПИ)
Профиль: Разработка программно-информационных систем (РИСб)
Кафедра информационных технологий и автоматизированных систем (ИТАС)

Зав. кафедрой: д-р экон. наук, проф.
Файзрахманов Р.А.________________________
«_________»_______________________  2018 г.


ЗАДАНИЕ
на выполнение выпускной квалификационной работы бакалавра
Фамилия, имя, отчество: Ларионов Александр Андреевич
Группа: РИС-14-1б
Начало выполнения работы: начало семестра в соответствии с учебным планом
Контрольные сроки просмотра работы кафедрой:
1) 10.04.18, 2) 24.04.18, 3) 15.05.18
Защита работы на заседании ГЭК: _________________
1. Наименование темы: «Разработка аппаратного и программного обеспечения системы управления исполнительными механизмами андроидного робота»
2. Исходные данные к работе: исходными данными могут являться список требований от руководителя проекта/заказчика, описание идеологии требуемой системы, наименование договора, по которому производится работа и т.д.
3. Содержание пояснительной записки: 
а)	исследовательский раздел.
одним предложением формулируется содержание исследовательского раздела
б)	конструкторский раздел:
одним предложением формулируется содержание конструкторского раздела
в)	технологический раздел:
одним предложением формулируется содержание технологического раздела
г) экономический раздел:
д) раздел информационной безопасности
4. Дополнительные указания:   
дополнительные указания могут включать некоторые ранее существовавшие наработки, которые использует автор ВКР
5. Основная литература:
указывается 4-5 основных источника и списка литературы, имеющих непосредственное отношение к предметной области работы
Руководитель ВКР:

уч. степень, должность Фамилия И.О.


Консультант по предметной области:

уч. степень, должность Фамилия И.О.


Задание получил:

полные ФИО студента


КАЛЕНДАРНЫЙ ГРАФИК ВЫПОЛНЕНИЯ
ВЫПУСКНОЙ КВАЛИФИКАЦИОННОЙ РАБОТЫ
Наименование этапа
Объем (в%)
Начало
Конец
Сбор и анализ исходных данных, постановка задачи
15
10.02.18
28.02.18
Изучение теоретического материала по предметной области; анализ и выбор методов и средств решения задачи
20
01.03.18
21.03.18
Разработка теоретической части, методики решения; Выбор и разработка средств решения задачи
20
22.03.18
13.04.18
Тестирование разработки, постановка экспериментов, формулировка выводов
20
14.04.18
04.05.18
Оформление пояснительной записки
25
05.05.18
29.05.18
Представление работы на проверку и отзыв руководителя квалификационной работы
-
30.05.18
03.06.18
Предварительная защита работы
-


Прохождение нормоконтроля
-


Представление работы
на кафедру
-


Защита на заседании ГЭК
-


Руководитель ВКР:

уч. степень, должность Фамилия И.О.


Задание получил:

Ларионов Александр Андреевич


ВНИМАНИЕ!
Титульные листы рекомендуется оформлять в отдельном документке, чтобы не нарушать разметку элементов страницы.
Места, куда вписываются фамилии оформлены, как таблицы со скрытыми границами, учтите это!

Направления и профили:

Направление: 09.03.01 – Информатика и вычислительная техника (ИВТ)
Профиль: Автоматизированные системы обработки информации и управления (АСУб)

Направление: 09.03.01  – Информатика и вычислительная техника (ИВТ)
Профиль: Вычислительные машины, комплексы, системы и сети (ЭВТб)

Направление: 09.03.04 – Программная инженерия (ПИ)
Профиль: Разработка программно-информационных систем (РИСб)

Руководитель ВКР – руководитель ВКР от ПНИПУ, в соответствии с приказом

Консультант по предметной области – руководитель от предприятия

Нормоконтролер – проверяющий ВКР на соответствие содержания и оформления требованиям


Предполагается:
а) разработка схемотехнических решений
б) разработка ПО микроконтроллера
в) разработка ПО бортовой ЭВМ робота.

Функции:
а) управление движением со стабилизацией по курсу, траектории, скорости.
б) управление питанием бортового оборудования с контролем целостности цепей питания и управления
в) управление «жестикуляцией» робота.


Собранное шасси «робота-референта» (на базе Промобота). Возможность управления им с ПК, пульта.

Ларионов А
РИС
Статья ВАК, выступление на конференции

Разработка аппаратного и программного обеспечения системы управления исполнительными механизмами андроидного робота

Структура НИР
1. Титул
2. Содержание
Возможно добавить разделы
3. Список иллюстраций
4. Список таблиц
5. Список листингов
Обязательно:
3. (6) Список сокращений
4. (7) Введение
Актуальнсть, науч. новизна, практич. значимость, цель, задачи
5. (8) Основная часть (Заголовки тут — это задачи из введения)
6. (9) Заключение
Обоснование достигнутые результаты (введение в прошедшем времени)
7. (10) Список литературы
Содержание
Введение	4
Задачи работы	4
Выполнение задач	6
Заключение	8
Список литературы	9
Приложение 1 Принципиальная схема робота	10
Приложение 2 Код проекта	11

= Введение =

Цель работы - ﻿разработка аппаратного и программного обеспечения системы управления исполнительными механизмами андроидного робота.
Для достижения поставленной цели необходимо решить следующие задачи:
1. Проанализировать существующие схемотехнические и алгоритмические решения для разработки аппаратно-программных комплексов.
2. Разработать подход к математическому моделированию в задачах разработки аппаратно-программных комплексов и выбор компонентов.
3. Спроектировать и разработать программный комплекс, реализующий предложенные методы и алгоритмы для микроконтроллера и бортовой ЭВМ робота.
4. Провести эксперименты для тестирования разработанных методов и алгоритмов.
Объектом исследования является программное и аппаратное обеспечение робота.
Предметом исследования являются методы и алгоритмы, используемые в программном и аппаратном обеспечении робота.

Актуальность темы исследования. В условиях развития информационных ресурсов одним из ключевых направлений современной компьютерной науки является разработка роботов. Процесс решения данных прикладных задач подразумевает, как правило, использование методов … . Актуальность разработки также обусловлена тем, что при создании такого рода систем нужно выявить все ошибки схемотехнического дизайна, а также ошибки в работе программного обеспечения.
Научная новизна исследования заключается в следующем:
1. Выработан и обоснован подход к разработке систем, развивающий существующие математические модели за счет возможности учесть особенности поставленной в работе задачи при ее формализации.
2. Создан программный комплекс для …  предложенных моделей и методов. Функционал системы позволяет осуществлять … , входящих в аппаратное обеспечение робота. ? Особенности модульной архитектуры позволяют гибко интегрировать программный комплекс в разрабатываемую систему . В целях осуществления обмена данных в программном комплексе предусмотрены интерфейсы связи между компонентами.

Практическая значимость ᔧ
В рамках данного исследования рассматривается задача создания программно аппаратного комплекса для … . Актуальность решения задач, связанных с …  и аппаратной части андроидного робота обоснована тем, что необходимо убедиться в правильности выполнения функций, для которых робот предназначен.
? Также решение данной задачи позволяет сократить сроки разработки конечного ПО для робота.
Разработанный программный комплекс может найти практическое применение и в других подобных системах.
Внедрение результатов. Результаты работы получили практическое применение и в других роботизированных комплексах.

Кроме того, на основе проведенного анализа методов и алгоритмов проекта сделан вывод о возможности и перспективности применения реализованной системы к решению данного рода задач.


= Анализ существующих схемотехнических решений =

== Обзор литературы ==
Проектирование и разработка андроидных роботов широко практикуется в настоящее время. Обратимся к литературе на данную тематику.
В статье /КХ/ представлена разработка аппаратно-программного комплекса для управления робототехнической платформой и программно- алгоритмического обеспечения для автономного движения и бесконтактного управления робототехнической платформой.
В ходе тестирования представленной в этой статье платформы была решена задача обработки данных с камеры Kinect и распознавания жестов оператора, отлажена передача данных на микроконтроллер Arduino Mega2560, разработана программа управления по передвижению робототехнической платформы в необходимых направлениях, апробированы модули ввода данных с датчиков.
Экспериментально подтверждено, что робототехническая платформа выполняет движения в необходимых направлениях с учетом локальных препятствий в режиме реального времени, на основе данных, получаемых с датчиков.
В статье /МСЛ/ описано создание кисти-манипулятора для андроидного робота. В робототехнике широкое распространение получили клешни для захвата различных предметов. Клешня состоит из двух направляющих, при сближении которых и происходит удержание предмета. Движения направляющих происходит с помощью сервоприводов.
На сегодняшний день большое распространение получили роботы-андроиды. Но практическое применение может иметь и рука (кисть руки) робота отдельно - в качестве протеза для инвалидов. Кисть используют в медицинской технике, в частности области медицинских средств реабилитации двигательного аппарата человека. Цель - повышение степени приспосабливания при захвате предметов. Пальца кисти андроида могут быть использованы для жестикуляции в развлекательных целях и для рекламы.
В статье /ККЮ/ рассмотрены перспективы развития мобильных робототехнических комплексов. Автор описывает что в настоящее время в мире наблюдается широкое распространение роботизированных систем и робототехники в целом. Во многих странах, в том числе и в Казахстане, робототехника является уже отдельной дисциплиной изучаемой в учебных заведениях, и не только в профильных вузах, но и в школах, и, соот- ветственно, в педагогических вузах.
Востребованность специалистов, обладающих знаниями в этой области,ежегодно растет. Это обусловлено многими объективными факторами, решающим из которых, конечно же, является бурное развитие робототехники.
Сферы применения роботов и робототехники различны: образование, ме- дицина, строительство, геодезия, метеорология и т.д.
Особое значение, так же занимает развитие так называемой, автономной и мобильной робототехники. В силу того, что робототехника зачастую применяется для выполнения работ в недоступных человеку местах, то именно мобильная робототехника часто является приоритетом. Однако, не только в перечисленных выше случаях требуется мобильная робототехника, определенной ветвью ее развития является автономная робототехника, подразумевающая практически полное исключение вмешательства человеческой деятельности для выполнения каких-либо задач. Иными словами, такая робототехника является наиболее перспективной и интересной в плане разработки. Для осуществления автономности, в мобильной робототехнике, все чаще применяется искусственный интеллект, а точнее его элементы. С развитием облачных технологий, стоит обратить внимание, на интеграцию и объединение различных по мощности вычислительных мощностей и сервисов искусственного интеллекта, для полномасштабной реализации полной мобилизации и автономности робототехники.
В статье /ШВК/ рассмотрена еще одна интересующая нас в рамках НИР область - системы технического зрения. Применение систем технического зрения (СТЗ) позволяет выполнять обнаружение и распознавание объектов окружающей среды, производить анализ ряда их характеристик. Поэтому включение СТЗ в состав робототехнических систем стало признанной тенденцией их развития.
СТЗ в составе робототехнической системы могут быть использованы для решения следую- щих задач:
обнаружение объектов;
определение формы объектов;
распознавание и классификация объектов; выделение изображений;
распознавание и классификация изображений. Указанные задачи в той или иной степени
могут быть решены с использованием одной СТЗ или совокупности СТЗ, в т. ч., основанных на различных физических принципах. Для решения задачи планирования траектории движения наи- более часто применяются СТЗ, построенные по принципу восприятия отражённого от объектов сигнала (инфракрасного или ультразвукового спектра), т. е., СТЗ радарного типа, сканирующие окружающее пространство. Для распознавания изображений необходимы СТЗ, позволяющие получить растровое представление сцены.
Применение таких СТЗ как видеокамеры, при соответствующей обработке данных позволяет решить как задачу планирования траектории, так и задачу распознавания, однако обработка растровых изображений требует больших вычислительных ресурсов и применения мощных вычис- лителей или специализированных сигнальных процессоров. Одной из основных проблем обработки и анализа изображений является неопределённость и неоднозначность их характеристик в связи с непостоянством освещённости, изменением цветовых характеристик и расположения объектов на фоне; кроме того, в ряде случаев применение аналитических методов обработки изображений во встраиваемых системах затруд- нено или невозможно по причине сложности используемого математического аппарата и, следовательно, ресурсоёмкости этих методов, из-за чего представляет интерес применение в таких задачах методов и средств интеллектуальной обработки данных (в частности, аппарата нечётких вычислений), эффективно решающих эти задачи при существенных ограничениях на вычислительные ресурсы. Отметим, что методы нечёткой обработки позволяют оперировать такими есте- ственными параметрами описания изображений, как яркость, однородность, близость участков и др., а также обладают простотой модификации, предсказуемостью и объяснимостью поведения.
Обобщенная структура использования средств нечётких вычислений в задачах обработки изо- бражения показана на рис. 1.
Существующие СТЗ коммерческого назначения и средства их разработки являются закрытыми и непригодными для исследований принципов построения СТЗ, создания новых методов и ал- горитмов их функционирования. Таким образом, актуальна задача разработки открытых средств проектирования встраиваемых СТЗ, позволяю- щих выполнять научные исследования и проводить подготовку специалистов в области автоматики и вычислительной техники.
В свою очередь, в статье /СЗ/ рассмотрена система управления движением автономной колесной платформы. В статье описан состав аппаратной и программной частей платформы и даны основные принципы проектирования таких устройств. Рассмотрим состав системы управления движением платформы подробнее: выбор направления движения аппарата осуществляет связка из нейронной сети (определяющей, в каком направлении находится маркер, обозначающий конечную точку маршрута) и системы нечеткой логики, выбирающей направление движения аппарата на основе данных нейронной сети и датчиков расстояния до препятствий. Выбранное направление движения преобразуется в команды и передается в систему управления движением. Система включает в себя микроконтроллер ArduinoDuemilanove на основе ATMega 328. Для управления работой двигателей предназначен силовой модуль расширения Ardumoto L298P MotorDriverShield. На модуле расширения для дополнительного прототипирования установлен модуль датчиков, оборудованный магнетометром и акселерометром. Кроме того, именно к этому модулю подключены ультразвуковые датчики расстояния, оценивающие расстояние до препятствий перед платформой слева и справа по направлению движения. По центру платформы в передней части расположен инфракрасный датчик препятствий, выдающий сигнал в случае, если препятствие находится прямо перед платформой на расстоянии 800 мм и менее.
Программное обеспечение микроконтроллера.
Движением аппарата управляет микроконтроллер, микропрограмма которого включает в себя блок инициализации, в котором производится настройка датчиков, а также основной цикл, в котором последовательно производится опрос датчиков аппарата, определение возможности движения в данный момент, остановка движения в случае наличия препятствия в непосредственной близости, передача телеметрической информации в бортовой компьютер, а также
прием и анализ команд, поступивших от бортового компьютера.
Одним из важнейших требований к программному обеспечению микроконтроллера являлась высокая надежность работы и устойчивость к возникновению прерываний и сбоев в канале передаче данных между бортовым компьютером и микроконтроллером. Исходя из этих требований, для реализации программного обеспечения микроконтроллера была выбрана концепция автоматного программирования. Часть программного кода, ответственная за командноинформационный обмен с бортовым компьютером, представляет собой конечный частично определенный детерминированный автомат-распознаватель. Автомат содержит 13 состояний и 26 переходов между ними. Прием числовых данных реализован отдельной процедурой, причем возникновение ошибки в ходе приема информации немедленно переводит автомат в исходное состояние, что обеспечивает высокую устойчивость системы к ошибкам и сбоям. Программное обеспечение на стороне бортового компьютера, принимающее телеметрические данные от микроконтроллера, реализовано по такому же принципу. Таким образом, сбой работы микроконтроллера так же не приводит к прекращению обменом информацией между бортовым компьютером и управляющим микроконтроллером или зависанию программы. Для возобновления нормального функционирования системы достаточно перезагрузить микроконтроллер либо бортовой компьютер, других специальных шагов предпринимать не требуется.
Выводы. Описанная выше система является частью мобильной платформы и была использована для обучения студентов по дисциплинам «Основы обработки изображений», «Нейронные сети» и «Нечеткая логика». Использование показало высокую эффективность предложенной системы, отсутствие сбоев во время работы и заинтересованность студентов в процессе обучения. В дальнейшем предполагается участие студентов в разработке программного обеспечения микроконтроллера, также возможна интеграция в состав системы управления, основанной на ROS (RoboticOperatingSystem).
Данная система может быть использована для проведения исследований и опытно-конструкторских работ в области робототехники, разработки автономных исследовательских систем и систем автоматического управления, а также для проведения практических занятий со студентами, бакалаврами и магистрантами соответствующих направлений.

Из изученной литературы были сделаны следующие выводы:
- создание андроидных роботов актуально в настоящее время, поскольку они могут быть использованы для решения различных задач;
- получены сведения о технологиях, используемых для создания андроидных роботов;
- рассмотрены конкретные примеры решения конструкторских и технологических задач в данной конкретной области.

== Перечень технического обеспечения, необходимого для сборки роботов ==

Традиционно для сборки робота используются:
- Микроконтроллер (например Arduino)
- Платы расширения для получения необходимого функционала (модули реле, Н-моста, БИНС, серво-приводы, электродвигатели, провода, ультразвуковые датчики расстояния, камеры, и т.д.)
- Бортовой компьютер
- Корпус из пластика, либо стекловолокна

Устройства объединяются в бортовую вычислительную сеть, которая выполняет все необходимые функции. Сеть использует протоколы передачи данных I2C, RS485 и USB.

== Схемотехнические решения ==

Общая структурная схема андроидного робота представлена на рисунке 1. Как можно видеть из этой схемы, (тут описание схемы).

Рис.1 Общая структурная схема андроидного робота
Согласно цели работы и данной структурной схемы необходимо разработать следующие блоки:
а) подсистема управления движением рук;
б) подсистема управления движением ног;
в) подсистема управления движением головы;
г) подсистема управления движением захватов кистей;
д) подсистема управления движением головы;
е) подсистема сбора информации с датчиков растояния;
ж) подсистема сбора информации с гироскопа;
з) подсистема управления питанием бортовой ЭВМ;
и) подсистема управления устройствами ЧМИ.

=== Описание подсистемы управления движением рук ===

К функциям подсистемы управления движением рук относятся:
- поднять левую руку
- поднять правую руку
- опустить левую руку
- опустить правую руку

Аппаратное обеспечение
- микроконтроллер
- драйвер мотора левой руки
- драйвер мотора правой руки
- концевые выключатели левой руки
- концевые выключатели правой руки

Опишем подробнее вышеперечисленные функции.
Чтобы поднять левую руку, нужно выставить высокий уровень на входе (каком) драйвера двигателя постоянного тока, подать ШИМ сигнал на (какой) вход драйвера при незамкнутых концевых выключателях руки. Необходимо отметить, что для экономии входов микроконтроллера верхний и нижний уровень руки конролируется одним и тем же входом. Это требует выделения дополнительных состояний автомата управления движением рук.

Автомат состояний рук является конечным автоматом. В начале работы рук он находится в состоянии инициализации и цивилизации и подходит под определение начала движения рук для поднятия оных вверх
//Описание всех функций управления движением робота далее

инициализация ; инициально опустить руки
инициально опустить руки ; остановка ; нажат к.в.
начать движ. вниз ; ошибка ; время > 10 сек
начать движ. вниз ; продолжить опускать руки ; к.в. отпущен
продолжить опускать руки ; ошибка ; время > 10 сек
продолжить опускать руки ; остановка ; к.в. нажат
начать движ. вверх ; ошибка ; время > 10 сек
начать движ. вверх ; продолжить поднимать руки ; к.в. отпущен
продолжить поднимать руки ; ошибка ; время > 10 сек
продолжить поднимать руки ; остановка ; к.в. нажат
остановка ; ожидание
ожидание ; начать движ. вниз ; принята команда вниз
ожидание ; начать движ. вверх ; принята команда вверх


=== Описание подсистемы управления движением ног ===

Здесь будет нарисована схема регулятора скорости и направления.

К функциям подсистемы управления движением ног относятся:
- проехать вперед на Х метров
- остановиться
- проехать назад на Х метров

Аппаратное обеспечение
- микроконтроллер
- драйвер мотора левой ноги
- драйвер мотора правой ноги

Опишем вышеперечисленные функции подробнее.
Для подсистемы управления движением ног определены следующие команды:
- 20: вернуть состояние подсистемы;
- 21 L C: движение вперед на L метров курсом C;
- 22 L C: движение назад на L метров курсом C;
- 23 : остановка.

Пример обмена командами:

21 320 200 // движение вперед на 320 см курсом 200
           // относительно начального положения робота
legs_last_cmd: 21, state: 1 // ответ подсистемы
           // с последней командой и состоянием
20 // запрос состояния
legs_last_cmd: 20, avg_pwm: 120, state: 1, direction: 1, trg_course: 200, course: 202, tgr_distance: 320, distance: 140, lft_pwm: 90, rgt_pwm: 150


=== Описание подсистемы управления движением головы ===

Голова робота может двигаться в 2ух плоскостях. Для поворота в горизонтальной плоскости и для наклона головы используются серво-моторы.

К функциям подсистемы управления движением головы относятся:
- повернуть голову на Х градусов влево
- повернуть голову на Х градусов вправо
- наклонить голову на Х градусов вперед
- наклонить голову на Х градусов назад

Аппаратное обеспечение
- микроконтроллер
- серво-моторы
- интерфейсная шина I2C
- драйвер серво-моторов

// Пример кода управления головой тут



=== Описание подсистемы управления движением захватов кистей ===

Для управления движением кистей рук используются серво-моторы.

К функциям подсистемы управления движением кистей рук относятся:
- сжать кисть левой руки
- сжать кисть правой руки
- отпустить кисть правой руки
- отпустить кисть левой руки

Аппаратное обеспечение
- микроконтроллер
- серво-моторы
- интерфейсная шина I2C
- драйвер серво-моторов

// Пример кода управления кистями рук тут

=== Описание подсистемы сбора информации с датчиков растояния ===


=== Описание подсистемы управления курсом с помощью гироскопа ===

Для сбора информации с гироскопа применяется шина I2C, и библиотека датчика GY_85. 
Сначала выполняется калибровка гироскопа, которая заключается в усреднении полученных значений для определения скорости дрейфа гироскопа.
Пример кода калибровки представлен ниже:

Блок схема !!

begin;

S = 0;
old_z = гироскоп(z);
for (i=0; i < 10; i++)
{
	задержка 0.3 сек;
	new_z = гироскоп(z);
	S = S + (new_z - old_z);
}
дрейф = S / 10;

end;

Пример управления курсом:

Блок схема тут будет.

begin;

gz += (гироскоп(z) - дрейф) * dt;
z = команда(курс);
левый(Sц + Kp * atan(z - gz));
правый(Sц - Kp * atan(z - gz));

delay(dt * 1000)

end;

=== Описание подсистемы управления питанием бортовой ЭВМ ===

Здесь должен быть алгоритм работы.

К функциям подсистемы управления питанием бортовой ЭВМ относятся:
- включить питание
- замкнуть кнопку включения питания ЭВМ
- 

Аппаратное обеспечение
- микроконтроллер
- модули реле
- бортовая ЭВМ
- блок питания бортовой ЭВМ

При включении питания микроконтроллера после инициализации всех подключенных устройств, выставляется низкий уровень на выходе, отвечающем за подачу питания на бортовую ЭВМ (низкий уровень сигнала замыкает реле), и на 100 мс замыкается цепь кнопки включения бортовой ЭВМ.

=== Описание подсистемы управления устройствами ЧМИ ===

К устройствам ЧМИ относятся дисплей, камеры, микрофон, динамики.

К функциям подсистемы управления устройствами ЧМИ относятся:
- включить дисплей
- включить камеры
- включить микрофон
- включить динамики

Аппаратное обеспечение
- микроконтроллер
- модули реле
- камеры 
- микрофон
- дисплей
- динамики

В состав системы управления платформы-робота обычно входят датчики для получения данных об окружающей обстановке и препятствиях, которые представлены ультразвуковыми дальномероми, гироскопом, акселерометром и т.д.. Для нормализации сигналов с этих датчиков служат преобразователи, осуществляющие преобразование аналоговых сигналов в унифицированный сигнал.
Преобразование унифицированных сигналов выполняют входные порты МК. К портам МК подключаются аппаратные драйверы управления исполнительными двигателями, обеспечивающие согласование сигналов по уровню токов, и аппаратные и программные интерфейсы, обеспечивающие связь с бортовой ЭВМ.
Также существуют решения, не использующее МК, решающее задачу связи между датчиками и бортовой ЭВМ посредством преобразователей интерфейсов, являющееся альтернативным способом организации внутрисистемных интерфейсов.
В ходе проекта решена инженерная задача создания механических звеньев, обеспечивающих ожидаемые линейные скорости и ускорения, допустимые внешние нагрузки и режимы работы.
Функциональная особенность аппаратно-программного комплекса состоит в интеллектуализации управления движением за счет использования локальных и визуальных датчиков. Система имеет априорную информацию о среде и в процессе функционирования получает текущую информацию как о внешней среде, так и о собственном состоянии. Ее целью является принятие решений, связанных с анализом внешней среды.
На основе проведенного исследования предметной области и анализа наиболее часто используемых компонентов в системах такого рода был сделан вывод о допустимости и достаточности применения микроконтроллера в связке с ЭВМ.
1.2 Алгоритмические решения
В разработке робота были использованы следующие алгоритмические решения:
1.2.1 
2. Разработка подхода к математическому моделированию в задачах разработки аппаратно-программных комплексов и выбор компонентов
2.1 Математичское моделирование
-Методология и методы исследования
При проведении исследования применялись методы следующих областей знаний: схемотехника, математическое моделирование, теория множеств, математическая статистика, структурное проектирование информационных систем, объектно-ориентированное программирование.
-Карта вероятности препятствий
-Работа рук и колёс (описать автомат)
-Управление 12 и 5в цепями и тд …
2.2 Выбор компонентов
Для разработки аппаратной части использовались плата arduino с микроконтроллером Atmega 2560, гироскоп, акселерометр, плата драйверов двигателя, блок реле, ультразвуковые датчики измерители расстояния, преобразователь интерфейсов USART → rs485→USB, серво-моторы, электродвигатели постоянного тока и другие компоненты. Также в системе присутствует бортовая ЭВМ для выполнения части (какой?) функций робота.
Для разработки программной системы использовался язык программирования C и библиотеки Arduino.

Подробно опишем выбранные компоненты.
Плата arduino с микроконтроллером Atmega 2560.
Выбор именно контроллера Atmega2560 обусловлен тем, что для работы всех устройств необходимо большое количество входов и выходов, что как раз и отличает этот контроллер от, например, atmega328 и др. подобных.
Гироскоп
Плата гироскопа с микросхемой MPU5060 удовлетворяет требованиям, предъявляемым к модулю, а именно наличие гироскопа, акселерометра и магнитного компаса в составе единого устройства с интерфейсом I2C.
Плата драйверов двигателя
Драйверы двигателей представлены микросхемой ..., которая представляет из себя H-мост с максимальным током 30А, чего более чем достаточно для имеющихся двигателей.
Блок реле
...
Ультразвуковые датчики измерители расстояния 
В системе используются ультразвуковые измерители расстояния HC-SR04. Их выбор обусловлен простотой работы с протоколом, который они используют.
Преобразователь интерфейсов USART → rs485 → USB
Для обеспечения связи между бортовой ЭВМ и контроллером используется шина rs485, и, соответственно, преобразователь интерфейсов. Он содержит в себе контроллер USB, микросхему MAX485, и микросхему для работы с USART. Его применение обусловлено необходимостью создания единой ЛВС робота, в которую входят все бортовые устройства.
Серво-моторы
Серво-моторы марки Китай великолепно справляются с задачами, на них возложенными.
Характеристики серво-моторов:

Питание	4,8 - 7,2 В
Угол поворота	180 градусов
Скорость без нагрузки	при 6,0 В: 0,14 сек/60 градусов
						при 7,2 В: 0,16 сек/60 градусов
Момент					при 6,0 В: 14 кг/см
						при 7,2 В: 15 кг/см
Вес	60 гр
Электродвигатели постоянного тока
От ВАЗ 2110 идеально подошли.

3. Проектирование и разработка программного комплекса, реализующиего предложенные методы и алгоритмы для микроконтроллера и бортовой ЭВМ робота.
???
При проектировании программного комплекса было решено использовать модульную структуру (.hpp и .cpp файлы). На МК должна быть реализована система реального времени (с некоторыми оговорками — какими?).
4. Проведение экспериментов для тестирования разработанных методов и алгоритмов.


= Заключение =
В результате выполнения НИР была разработана система ??? аппаратного и программного обеспечения андроидного робота.
Решены все поставленные задачи:

Результаты внедрения системы - ??? аппаратной и программной части МРК, и сделан вывод о его пригодности к дальнейшему использованию.

Список литературы
КХ. Кондратьев К.Л., проф. Харитонов В.И. Аппаратно-программный комплекс для управления платформой-роботом // Известия МГТУ «МАМИ». - 2014. - №No 2(20).
МСЛ. Михед А.Д., Смирнова Е.Е., Липатова Ю.В. Моделирование манипулятора кисти андроида // Известия ТулГУ. Технические науки.. - 2016. - №11. Ч. 2.
ККЮ. Колыванов К.Ю. Перспективы мобильной робототехники // Северо-Казахстанский государственный университет им. М. Козыбаева. - 2016.
ШВК. Шилов М.М., Воробьёва О.С., Кракау Т.К. Применение систем технического зрения и средств нечётких вычислений в интеллектуальных устройствах автоматики и робототехники // Научно-технические ведомости СПбГТУ. - 2010. - №2.
СЗ. Саяпин А.В., Зотин А.Г. Система управления движением автономной колесной платформы // Решетневские чтения. - 2015.
2. Описание интерфейсной шины I2C протокола передачи данных по ней // URL: http://easyelectronics.ru/interface-bus-iic-i2c.html (дата обращения: 28.10.2017).
3. Инерциальная навигационная система // URL: www.nngasu.ru/geodesy/classification/chastnye-klassifikatsii/11_Inercialnie_sistemi.php (дата обращения: 10.07.2017).
4. Описание библиотеки и примеры работы с платой GY-85 // URL: https://github.com/madc/GY-85 (дата обращения: 17.09.2017).
5. Анишин Н.С., Булатникова И.Н., Гершунина Н.Н. Алгоритмические проблемы применения микропроцессорных средств в робототехнике // Известия ТРТУ Тематический выпуск Компьютерные технологии в инженерной и управленческой деятельности. - 2008. - №3.

Приложение 1 Принципиальная схема робота

Приложение 2 Код проекта
#include <IRremoteInt.h>
#include <IRremote.h>
#include <Wire.h>
#include <GY_85.h>
#include <math.h>
#define IR_USE_TIMER2

#define M1AIN PA0 // 22 -> 1 (IN A on scheme)
#define M1BIN PA1 // 23 -> 6
#define M1PWM PA2 // 24 -> 5
// #define M1AEN PA3 // 25 -> 2
// #define M1BEN PA4 // 26 -> 3 (IN B on scheme)

#define LFTSTSWPIN PB0
#define RGTSTSWPIN PB1

#define LH_NOT_LIMIT (PINB & _BV(LFTSTSWPIN)) == 1
#define LH_LIMIT !LH_NOT_LIMIT
#define RH_NOT_LIMIT (PINB & _BV(RGTSTSWPIN)) == 1
#define RH_LIMIT !RH_NOT_LIMIT

#define M2AIN PC4 // 33 -> 1
#define M2BIN PC3 // 34 -> 6
#define M2PWM PC2 // 35 -> 5
// #define M2AEN PC1 // 36 -> 2
// #define M2BEN PC0 // 37 -> 3

#define S0TRI PL0
#define S1TRI PL1
#define S2TRI PL2
#define S3TRI PL3

#define AIN PE5
#define VIN PG5
#define MOSFET PE3

//#define RH_GO_UP PORTL |= _BV(RHUP)
//#define RH_GO_DOWN PORTL |= _BV(RHDOWN)
#define LH_STOP PORTG &= ~_BV(LEFTHAND)
#define RH_STOP PORTG &= ~_BV(RIGHTHAND)

#define RIGHTHAND PG1 // 40
#define LEFTHAND PG0 // 41
#define RHUP PL4 // 45
#define LHUP PL5 // 44
#define RHDOWN PL6 // 43
#define LHDOWN PL7 // 42

#define VCC_RELAY PB4 //5V
#define MOTORS_RELAY PB5 //12V
#define LCD_RELAY PB6 //12V
#define COMP_RELAY PB7 //12V

// #define SECHO PB0

#define LEFT  16716015
#define RIGHT 16734885
#define FWD   16718055
#define BACK  16730805
#define STOP  16726215
#define RIGHTHANDUP 16761405
#define RIGHTHANDDOWN 16748655
#define RIGHTHANDSTOP 16756815
#define LEFTHANDUP 16720605
#define LEFTHANDDOWN 16769055
#define LEFTHANDSTOP 16738455
#define NOCMD 0x00

#define LH_IS_NEW_CMD (LH_Command != old_LH_Command)
#define RH_IS_NEW_CMD (RH_Command != old_RH_Command)

#define HANDS_PWM_UP 254
#define HANDS_PWM_DN 100

GY_85 GY85;

float gz = 0;
float pure_gz = 0;
float z = 0;
float dt = 0.01;
float delta = 0.0;
float old_z = 0;
float new_z = 0;
float Kp = 10;
uint16_t tme = 0;
uint8_t lft_pwm = 0;
uint8_t rgt_pwm = 0;
unsigned long cmd = 0;
int RECV_PIN = 2;

IRrecv irrecv(RECV_PIN);
decode_results results;

float trg_spd = 0;

typedef enum HAND_STATE {
HAND_STATE_INIT,
HAND_STATE_GO_DOWN,
HAND_STATE_SPIN_UP,
HAND_STATE_SPIN_DOWN,
HAND_STATE_BEGIN_SPIN_UP,
HAND_STATE_BEGIN_SPIN_DOWN,
HAND_STATE_STOP,
HAND_STATE_SPIN_FAIL,
HAND_STATE_IDLE
} State_t;

volatile State_t LH_State, RH_State = HAND_STATE_INIT;
volatile uint32_t LH_Command, old_LH_Command, RH_Command, old_RH_Command = 0;
volatile uint16_t LH_Time, RH_Time = 0;
volatile State_t old_LH_State, old_RH_State = NULL;
volatile uint8_t hands_pwm = 0;
volatile uint8_t adc_val = 0;

// DDRF |= (1 << M1PWM);
// DDRK |= (1 << M2PWM);

// Set Timer 0 prescaler to clock/8.
// At 9.6 MHz this is 1.2 MHz.
// See ATtiny13 datasheet, Table 11.9.
// TCCR0B |= (1 << CS01);

// // Set to 'Fast PWM' mode
// // Enable 'Fast PWM'
// TCCR0A |= (1 << WGM01) | (1 << WGM00);

// // Clear OC0B and OC0A(!!!) output on compare match, upwards counting.
// TCCR0A |= (1 << COM0A0) | (1 << COM0B0);

void measure_v()
{

}

void measure_a()
{

}

void charge()
{

}

void lft_stop()
{
lft_pwm = 0;
}

void rgt_stop()
{
rgt_pwm = 0;
}

void lft_frw(float spd) //TODO ; m/s!!!
{
PORTA |= _BV(M1AIN);
PORTA &= ~_BV(M1BIN);

lft_pwm = (int) max(min(spd,255),0);
// OCR0A = lft_pwm;
}

void rgt_frw(float spd)
{
PORTC |= _BV(M2AIN);
PORTC &= ~_BV(M2BIN);

rgt_pwm = (int) max(min(spd,255),0);
// analogWrite(M2PWM, rgt_pwm);
}

void process_IR_cmd(unsigned long cmd)
{
switch (cmd)
{
case LEFT:
z -= 10;
break;
case RIGHT:
z += 10;
break;
case FWD:
trg_spd += 10;
break;
case BACK:
trg_spd -= 10;
break;
case STOP:
trg_spd = 0;
z = 0;
break;
case LEFTHANDUP:
LH_Command = LEFTHANDUP;
break;
case LEFTHANDDOWN:
LH_Command = LEFTHANDDOWN;
break;
case LEFTHANDSTOP:
RH_Command = LEFTHANDSTOP;
break;
case RIGHTHANDUP:
RH_Command = RIGHTHANDUP;
break;
case RIGHTHANDDOWN:
RH_Command = RIGHTHANDDOWN;
break;
case RIGHTHANDSTOP:
RH_Command = RIGHTHANDSTOP;
break;
}
z = min(max(-180, z), 180);
trg_spd = min(max(0, trg_spd), 255);
}

void setup()
{
Wire.begin();
Serial.begin(9600);
GY85.init();
irrecv.enableIRIn();

old_z = GY85.gyro_z(GY85.readGyro());
for (int i=0; i < 10; i++)
{
delay(300);
new_z = GY85.gyro_z(GY85.readGyro());
delta += new_z - old_z;
}
delta /= 10;

noInterrupts();           // disable all interrupts

TCCR1A = 0;
TCCR1B = 0;
TCNT1  = 0;

OCR1A = 3125;            // compare match register 16MHz/256/2Hz
// OCR1A = 3125;            // compare match register 16MHz/256/2Hz
TCCR1B |= (1 << WGM12);   // CTC mode
TCCR1B |= (1 << CS10);    // 1024 prescaler
TIMSK1 |= (1 << OCIE1A);  // enable timer compare interrupt

DDRA |= _BV(M1AIN) | _BV(M1BIN) | _BV(M1PWM);
DDRB |= _BV(LFTSTSWPIN) | _BV(RGTSTSWPIN);
DDRC |= _BV(M2AIN) | _BV(M2BIN) | _BV(M2PWM);
DDRL |= _BV(S0TRI) | _BV(S1TRI) | _BV(S2TRI) | _BV(S3TRI) | _BV(RHUP) | _BV(LHUP) | _BV(RHDOWN) | _BV(LHDOWN);
DDRG |= _BV(RIGHTHAND) | _BV(LEFTHAND);

//ADC setup
ADCSRA |= (1 << ADPS2)
         | (1 << ADPS1)
         | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample rate @ 16MHz
  	// ADMUX |= (1 << REFS0); // Set ADC reference to AVCC

    ADMUX |= (1 << ADLAR); // Left adjust ADC result to allow easy 8 bit reading
ADCSRA |= (1 << ADATE);
ADCSRA |= (1 << ADEN);  // Enable ADC
ADCSRA |= (1 << ADIE);  // Enable ADC Interrupt

ADMUX &= ~(1 << MUX0)
    &  ~(1 << MUX1)
    &  ~(1 << MUX2)
    &  ~(1 << MUX3);

interrupts();             // enable all interrupts
}


void LH_GO_UP() {	PORTL |= _BV(LHUP); PORTL &= ~_BV(LHDOWN); PORTG |= _BV(LEFTHAND); }
void LH_GO_DOWN() {  PORTL |= _BV(LHDOWN); PORTL &= ~_BV(LHUP); PORTG |= _BV(LEFTHAND); }

void RH_GO_UP() {	PORTL |= _BV(RHUP); PORTL &= ~_BV(RHDOWN); PORTG |= _BV(RIGHTHAND); }
void RH_GO_DOWN() {  PORTL |= _BV(RHDOWN); PORTL &= ~_BV(RHUP); PORTG |= _BV(RIGHTHAND); }

unsigned long readIRC()
{
unsigned long res = NOCMD;
if (irrecv.decode(&results)) {
res = results.value;
irrecv.resume();
}
return res;
}

void rigthHandWork()
{
switch (RH_State)
{
case HAND_STATE_INIT:
RH_Time = 0;
RH_State = HAND_STATE_GO_DOWN;
break;
case HAND_STATE_GO_DOWN:
old_RH_Command = RIGHTHANDDOWN;
RH_GO_DOWN();
if (RH_LIMIT || (++RH_Time > 1000)) RH_State = HAND_STATE_STOP;
break;
case HAND_STATE_BEGIN_SPIN_DOWN:
RH_GO_DOWN();
if (++RH_Time > 10000) RH_State = HAND_STATE_SPIN_FAIL;
if (!RH_LIMIT & (++RH_Time > 10)) RH_State = HAND_STATE_SPIN_DOWN;
break;
case HAND_STATE_SPIN_DOWN:
RH_GO_DOWN();
if (++RH_Time > 10000) RH_State = HAND_STATE_SPIN_FAIL;
if (RH_LIMIT) RH_State = HAND_STATE_STOP;
break;
case HAND_STATE_BEGIN_SPIN_UP:
RH_GO_UP();
if (++RH_Time > 10000) RH_State = HAND_STATE_SPIN_FAIL;
if (!RH_LIMIT & (++RH_Time > 10)) RH_State = HAND_STATE_SPIN_UP;
break;
case HAND_STATE_SPIN_UP:
RH_GO_UP();
if (++RH_Time > 10000) RH_State = HAND_STATE_SPIN_FAIL;
if (RH_LIMIT) RH_State = HAND_STATE_STOP;
break;
case HAND_STATE_STOP:
RH_STOP;
RH_Time = 0;
RH_State = HAND_STATE_IDLE;
break;
case HAND_STATE_SPIN_FAIL:
RH_STOP;
RH_Time = 0;
break;
case HAND_STATE_IDLE:
if ((RH_IS_NEW_CMD) & (RH_Command == RIGHTHANDUP))
{
RH_State = HAND_STATE_BEGIN_SPIN_UP;
RH_Time = 0;
old_RH_Command = RH_Command;
}
if ((RH_IS_NEW_CMD) & (RH_Command == RIGHTHANDDOWN))
{
RH_State = HAND_STATE_BEGIN_SPIN_DOWN;
RH_Time = 0;
old_RH_Command = RH_Command;
}
break;
}
old_RH_State = RH_State;
}


void leftHandWork()
{
switch (LH_State)
{
case HAND_STATE_INIT:
hands_pwm = 0;
LH_Time = 0;
LH_State = HAND_STATE_GO_DOWN;
break;
case HAND_STATE_GO_DOWN:
hands_pwm = HANDS_PWM_DN;
old_LH_Command = LEFTHANDDOWN;
LH_GO_DOWN();
if (LH_LIMIT || (++LH_Time > 1000)) LH_State = HAND_STATE_STOP;
break;
case HAND_STATE_BEGIN_SPIN_DOWN:
hands_pwm = HANDS_PWM_DN;
LH_GO_DOWN();
if (++LH_Time > 10000) LH_State = HAND_STATE_SPIN_FAIL;
if (LH_NOT_LIMIT & (++LH_Time > 10)) LH_State = HAND_STATE_SPIN_DOWN;
break;
case HAND_STATE_SPIN_DOWN:
hands_pwm = HANDS_PWM_DN;
LH_GO_DOWN();
if (++LH_Time > 10000) LH_State = HAND_STATE_SPIN_FAIL;
if (LH_LIMIT) LH_State = HAND_STATE_STOP;
break;
case HAND_STATE_BEGIN_SPIN_UP:
hands_pwm = HANDS_PWM_UP;
LH_GO_UP();
if (++LH_Time > 10000) LH_State = HAND_STATE_SPIN_FAIL;
if (LH_NOT_LIMIT & (++LH_Time > 10)) LH_State = HAND_STATE_SPIN_UP;
break;
case HAND_STATE_SPIN_UP:
hands_pwm = HANDS_PWM_UP;
LH_GO_UP();
if (++LH_Time > 10000) LH_State = HAND_STATE_SPIN_FAIL;
if (LH_LIMIT) LH_State = HAND_STATE_STOP;
break;
case HAND_STATE_STOP:
hands_pwm = 0;
LH_STOP;
LH_Time = 0;
LH_State = HAND_STATE_IDLE;
break;
case HAND_STATE_SPIN_FAIL:
hands_pwm = 0;
LH_STOP;
LH_Time = 0;
break;
case HAND_STATE_IDLE:
if ((LH_IS_NEW_CMD) & (LH_Command == LEFTHANDUP))
{
LH_State = HAND_STATE_BEGIN_SPIN_UP;
LH_Time = 0;
old_LH_Command = LH_Command;
}
if ((LH_IS_NEW_CMD) & (LH_Command == LEFTHANDDOWN))
{
LH_State = HAND_STATE_BEGIN_SPIN_DOWN;
LH_Time = 0;
old_LH_Command = LH_Command;
}
break;
}
old_LH_State = LH_State;
}


void loop()
{
pure_gz = GY85.gyro_z(GY85.readGyro());
gz += (pure_gz - delta) * dt;
cmd = readIRC();
if (cmd != NOCMD)
{
process_IR_cmd(cmd);
}

lft_frw(trg_spd + Kp * atan(z - gz));
rgt_frw(trg_spd - Kp * atan(z - gz));
if(++tme > 100)
{
tme = 0;
// Serial.print("\tpure_gz "); Serial.print(pure_gz);
// Serial.print("\tgz ");      Serial.print(gz);
// Serial.print("\tlft_pwm "); Serial.print(lft_pwm);
// Serial.print("\trgt_pwm "); Serial.print(rgt_pwm);
// Serial.print("\ttrg_spd "); Serial.print(trg_spd);
// Serial.print("\tz "); 		Serial.print(z);
Serial.print("\trh_state "); 		Serial.print(RH_State);
Serial.print("\trh_cmd "); 		Serial.print(RH_Command);
Serial.print("\trh_old_cmd "); 		Serial.print(RH_Command);
Serial.print("\trh_not_limit "); 		Serial.print(RH_NOT_LIMIT);
// (LH_Command != old_LH_Command) & !LH_NOT_LIMIT
Serial.print("\trh_is_new_cmd "); 		Serial.print(RH_IS_NEW_CMD);
Serial.print("\tadc_val "); 		Serial.print(adc_val);

Serial.print("\tcmd ");     Serial.print(cmd);
Serial.println();
}

delay(dt * 1000);
}

volatile uint8_t legs_cnt = 0;
volatile uint8_t hands_cnt = 0;
volatile uint8_t m1cnt = 0;
volatile uint8_t m2cnt = 0;
volatile uint8_t mhcnt = 0;

void handsWork()
{
if (hands_cnt++ == 0)
{
leftHandWork();
rigthHandWork();
mhcnt = 0;
}
if (mhcnt++ > hands_pwm)
{
LH_STOP;
RH_STOP;
}
}

void legsWork()
{
if (legs_cnt++ == 0)
{
PORTA |= _BV(M1PWM);
PORTC |= _BV(M2PWM);
m1cnt = m2cnt = 0;
}
if (m1cnt++ > lft_pwm)
{
PORTA &= ~_BV(M1PWM);
}
if (m2cnt++ > rgt_pwm)
{
PORTC &= ~_BV(M2PWM);
}
}

ISR(TIMER1_COMPA_vect)
{
TCNT1 = 0;
handsWork();
// legsWork();
}

ISR(ADC_vect) {
ADCSRA |= (1 << ADSC);  // Start A2D Conversions
while(!(ADCSRA & (1<<ADIF)));
ADCSRA|=(1<<ADIF);
adc_val = ADCH;
}
