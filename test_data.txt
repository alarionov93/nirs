
билет 1	3
+1. Оператор SQL– SELECT (выборка).	3
+2. Понятие ООП. Основные принципы: инкапсуляция.	4
3. Разработка собственных коллекций, в том числе обобщенных. Разработать класс-коллекцию	5
билет 2	7
+1. Обработка исключений.	7
2. Формирование команды. Стадия Планирования	7
-3. Организация ввода-вывода с использованием потоковых классов. Разработать иерархию классов	9
билет 3	11
+1. Библиотека STL. Итераторы. Классы-контейнеры.	11 python
2. Формирование команды. Стадия Внедрения	12
+3. Разработка приложения с использованием иерархии наследования.	13
Билет 4	16
1. Потоковые классы. Библиотека потоковых классов	16
2. Стадия Разработки. Стадия Стабилизации	16
+3. - найти города, названия которых начинается на латинскую букву ‘A’.	17
билет 5	18
+1. Реляционная модель данных.	18
+2. Понятие ооп. Основные принципы: наследование и полиморфизм.	18
+3. найти страны, где продолжительность жизни превосходит Россию;	19
билет 6	21
+1. Метод «сущность – связь». Основные понятия метода	21
2. Расстановка приоритетов исполнения проекта. Структурирование работ по этапам	21
+3. Проектирование иерархии классов. Определить абстрактный класс. Определить иерархию классов, в основе которой будет находиться абстрактный класс.	21
билет 7	23
1.  Стадия Разработки. Стадия Стабилизации	23
+2. Перегрузка операций. Перегрузка унарных и бинарных операций.	23
+3. Используя язык SQL написать запрос для таблицы Table1 с атрибутами ID и DATETIME	24
билет 8	25
+1. Оператор SQL– SELECT (выборка). Предложения FROM, WHERE	25
2. Формирование команды. Стадия Выработки концепции	26
+3. Использование классов и алгоритмов стандартной библиотеки шаблонов. Создать контейнер из библиотеки STL.	27
билет 9	29
-1. Шаблоны функций и классов. Шаблоны функций. Шаблоны классов.	29
2. Формирование команды. Стадия Планирования	29
+3. - найти количество городов в каждой стране;	31
билет 10	32
1. Формирование команды. Стадия Внедрения	32
+2. Язык SQL. Предложения SQL: CREATE, DROP	33
+3. Разработка пользовательских классов и объектов. Определить пользовательский класс. Определить в классе конструкторы без параметров	34
билет 11	35
+1. Понятие ООП. Основные принципы: инкапсуляция.	35
2. Расстановка приоритетов исполнения проекта. Структурирование работ по этапам	36
+3. найдите количество стран в каждом континенте;	37
билет 12	38
+1. Метод «сущность – связь». Основные понятия метода	38
2. Формирование команды. Стадия Внедрения Флюгегенхаймен	38
+3. Проектирование иерархии классов. Определить абстрактный класс. Определить иерархию классов, в основе которой будет находиться абстрактный класс	39
билет 13	41
+1. Оператор SQL– SELECT (выборка). Предложения FROM, WHERE	41
2. Стадия Разработки. Стадия Стабилизации	42
+3. Использование классов и алгоритмов стандартной библиотеки шаблонов. Создать контейнер из библиотеки STL.	42
билет 14	45
1. Расстановка приоритетов исполнения проекта. Структурирование работ по этапам	45
+2. Язык SQL. Предложения SQL: CREATE, DROP	45
+3. Разработка пользовательских классов и объектов. Определить пользовательский класс.	45


билет 1
1. Оператор SQL– SELECT (выборка). 
SELECT – оператор запроса, возвращающий набор данных из базы данных.

SELECT [DISTINCT | ALL] <выражение для столбца | *> AS <псевдоним>
FROM <имя таблицы> AS <псевдоним>
WHERE <предикат>
GROUP BY <список столбцов>
HAVING <условие на агрегатные значения>
ORDER BY <список столбцов>

Выборка может содержать дубликаты строк. Если требуется получить уникальные строки, то можно использовать ключевое слово DISTINCT или ALL для всех строк (по умолчанию).
Предложение WHERE <предикат> реализует горизонтальную выборку. При этом в результирующий набор попадут только те строки из источника записей, для каждой из которых значение предиката равно TRUE.
Агрегатные функции
COUNT(*)
Возвращает количество строк источника записей.
COUNT(<имя поля>)
Возвращает количество значений в указанном столбце.
SUM(<имя поля>) 
Возвращает сумму значений в указанном столбце.
AVG(<имя поля>)
Возвращает среднее значение в указанном столбце.
MIN(<имя поля>)
Возвращает минимальное значение в указанном столбце.
MAX(<имя поля>) 
Возвращает максимальное значение в указанном столбце.

Предложение GROUP BY используется для объединения результатов выборки по одному или нескольким столбцам.
Если запрос не содержит предложения GROUP BY, то агрегатные функции, включенные в предложение SELECT, исполняются над всеми результирующими строками запроса. Если запрос содержит предложение GROUP BY, каждый набор строк, который имеет одинаковые значения столбца или группы столбцов, заданных в предложении GROUP BY, составляет группу, и агрегатные функции выполняются для каждой группы отдельно.

Предложение HAVING применяется для фильтрации группировки (для проверки значений, которые получены с помощью агрегатной функции не из отдельных строк источника записей, определенного в предложении FROM, а из групп таких строк).
SELECT model, COUNT(model), AVG(price) 
FROM Pc 
GROUP BY model 
HAVING AVG(price) < 800;

Чтобы упорядочить строки выборки, можно выполнить сортировку по любому количеству полей, указанных в предложении SELECT. Для этого используется предложение ORDER BY <список полей>, являющееся всегда последним предложением в операторе SELECT. При этом в списке полей могут указываться как имена полей, так и их порядковые позиции в списке предложения SELECT.

SELECT DISTINCT speed, ram 
FROM Pc 
ORDER BY ram 
DESC
Сортировку можно проводить по возрастанию (параметр ASC принимается по умолчанию) или по убыванию (параметр DESC).

2. Понятие ООП. Основные принципы: инкапсуляция. 
(ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования
При объектно-ориентированном подходе к программированию программа представляет собой совокупность взаимодействующих между собой данных — объектов. Функциональную возможность и структуру объектов задают классы — типы данных, определенные пользователем. При рассмотрении объектов выделяется то, что объекты принадлежат одному или нескольким классам, которые определяют поведение (являются моделью) объекта. классы могут задавать поля .
Поля класса являются переменными, объявленными внутри класса. Они предназначены для хранения данных во время работы экземпляра класса (объекта). В описании класса поля должны предшествовать методам и свойствам. Обычно поля используются для обеспечения выполнения операций внутри класса.
Для получения и передачи данных в классе применяются 
Свойства. Свойства представляют собой атрибуты, которые составляют индивидуальность объекта и помогают описать его. Так как свойство обеспечивает обмен данными с внешней средой, то для доступа к его значению используются специальные Методы класса. Поэтому обычно свойство определяется тремя элементами: полем и двумя методами, которые осуществляют его чтение/запись
ООП основано на «трех китах» - трех важнейших принципах, придающих объектам новые свойства. Этими принципами являются инкапсуляция, наследование и полиморфизм.
Инкапсуляция есть объединение в единое целое данных и алгоритмов обработки этих данных. “Инкапсуляция" можно расшифровать как "заключение в капсулу". Если проще - это "обеспечение безопасности" в Java. В каждой программе есть параметры, к которым нельзя давать доступ всем.Инкапсуляция позволяет в максимальной степени изолировать объект от внешнего окружения. Она существенно повышает надежность разрабатываемых программ, т.к. локализованные в объекте алгоритмы обмениваются с программой сравнительно небольшими объемами данных, причем количество и тип этих данных обычно тщательно контролируются. В результате замена или модификация алгоритмов и данных, инкапсулированных в объект, как правило, не влечет за собой плохо прослеживаемых последствий для программы в целом. 
Управление доступом. Принцип инкапсуляции обеспечивается вводом в класс областей доступа:
	•	private — закрытый, доступный только собственным методам;
	•	public — открытый, доступный любым функциям; 
	•	protected — защищенный, доступный только собственным методам и методам производных классов. 
Члены класса, находящиеся в закрытой области (private), недоступны для использования со стороны внешнего кода. Пользователь не может использовать закрытые данные и методы.Напротив, члены класса, находящиеся в открытой секции (public), доступны для использования со стороны внешнего кода. Пользователь может взаимодействовать с объектом только через интерфейс. При описании класса каждый член класса помещается в одну из перечисленных выше областей доступа
Статические компоненты класса. Члены класса могут быть объявлены с использованием модификатора класса памяти static. Такие члены данных разделяются всеми экземплярами данного класса и хранятся в одном месте. Нестатические члены данных создаются для каждой переменной-объекта класса. Отсутствие возможности объявлять статические члены класса привело бы к необходимости объявлять эти данные на глобальном уровне программы. Это разорвало бы отношения между данными и их классом, а также не согласуется с основной парадигмой ООП – объединение в классе данных и методов для их обработки. Статический член позволяет данным класса, которые не специфичны для отдельного экземпляра, существовать в области видимости класса.
Инициализация объектов. При объявлении переменной, как правило, ее инициализируют.Кроме обычных методов в классах используются также и специальные методы, которые называются конструкторами. Конструкторы вызываются при создании нового объекта данного класса. Конструкторы выполняют инициализацию объекта. Конструктор определяет, как будет создаваться новый объект, когда это необходимо, может распределить под него память и инициализировать ее. Он может включать в себя код для распределения памяти, присваивание значений элементам, преобразование из одного типа в другой и многое полезное.
Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор без параметров.

3. Разработка собственных коллекций, в том числе обобщенных. Разработать класс-коллекцию
MyVector.cpp
template<typename T>
class MyVector {
private:
T *elements;
int size;
public:
MyVector() {
this.size = 0;
}

MyVector(int size) {
this.size = size;
this.elements = new T[size];
}

void push_back(T value) {
T *temp = new T[this.size + 1];
std::copy(this.elements, this.elements + size, temp);
delete [] this.elements;
this.elements = temp;
this.elements[size] = value;
this.size++;
}

void push_back(T *value, int n) {
T *temp = new T[this.size + n];
std::copy(this.elements, this.elements + size, temp);
std::copy(value, value + n, temp + n);
delete [] this.elements;
this.elements = temp;
this.size += n;
}

int size() {
return this.size;
}
};

/**
Допустим, имеется следующая иерархия классов:
Person - абстрактный класс
Student - класс, наследующийся от Person
Teacher - класс, наследующийся от Person
*/
main.cpp
int main (int argc, const char *argv[]) {
MyVector<Person> vec();
Student *students = new Student[2];
students[0] = new Student();
students[1] = new Student();
Teacher t = new Teacher();
vec.push_back(students, 2);
vec.push_back(t);
return (0);
}
билет 2
1. Обработка исключений.
Исключение (Java) - это ошибка возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:
	•	Пользователь ввел некорректные данные.
	•	Файл, к которому обращается программа, не найден.
	•	Сетевое соединение с сервером было утеряно во время передачи данных. и т.д. 
Обработка исключительных ситуаций (exception handling) — механизм языков программирования, предназначенный для описания реакции программы на возможные исключения, которые могут возникнуть при выполнении программы и приводят к невозможности (бессмысленности) дальнейшей отработки программой её базового алгоритма
Синтаксис:
	•	try - данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке. 
	•	catch - ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
	•	finally - ключевое слово для отметки начала блока кода, которое является дополнительным. Этот блок помещается после последнего блока 'catch'. Управление обычно передаётся в блок 'finally' в любом случае. 
	•	throw - служит для генерации исключений.
	•	throws - ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.

Исключения делятся на checked и unchecked:
	•	checked - проверяемые. Их можно обработать во время выполнения программы. Должны обрабатываться блоком catch или описываться в сигнатуре метода. 
	•	unchecked - непроверяемые. Могут не обрабатываться и не быть описанными.


Иерархия исключений:
	•	Throwable (checked)	
	•	Exception (checked)	
	•	RuntimeException (unchecked)	
	•	остальные наследники  (checked)	
	•	Error (unchecked)
Также из исключений можно получить дополнительную информацию с помощью методов:
	toString()  - Возврат имени класса, соединенного с результатом getMessage().
	getCause() - в том случае, если к исключению были добавлены дополнительные исключения выведет их в консоль.
	getMessage() - Возврат подробного сообщения о произошедшем исключении. Инициализация данного сообщения производится в конструкторе Throwable.
	toString()  - Возврат имени класса, соединенного с результатом getMessage().

Спицификация
Если внутри метода возможен выброс исключения и он не обрабатывается блоком try catch - то в сигнатуру метода должна быть добавления соответствующая спецификация более высокого уровня
	methodName() throws Exception
			throws ArithmeticException

В данном случае 

2. Формирование команды. Стадия Планирования
Microsoft Solutions Framework (MSF)-методология разработки программного обеспечения, предложенная корпорацией Microsoft. MSF опирается на практический опыт Microsoft и описывает управление людьми и рабочими процессами в процессе разработки решения. 
MSF представляет собой согласованный набор концепций, моделей и правил.
Модель процессов включает такие основные фазы процесса разработки:
· Выработка концепции (Envisioning)
· Планирование (Planning)
· Разработка (Developing)
· Стабилизация (Stabilizing)
· Внедрение (Deploying)
Формирование команды
Модель команды проекта MSF не предусматривает формирования какой-либо специальной организационной структуры или введения специальных должностей. Все работы выполняются представителями соответствующих ролевых кластеров.
Состав команды определяется теми целями, которые необходимо достичь для успеха проекта: за достижение конкретной цели отвечает соответствующий ролевой кластер, а за успешность проекта в целом несет ответственность вся команда. В соответствии с целями проекта MSF выделяет шесть ролевых кластеров, каждый из которых должен обладать специфическими компетенциями для исполнения собственных функций:
• Управление продуктом. Цель: Удовлетворение Заказчиков.
• Управление программой. Цель: Достижение результата в рамках проектных ограничений.
•Разработка. Цель: Создание продукта в соответствии со спецификацией.
• Тестирование. Цель: Одобрение выпуска продукта только лишь после того, как все дефекты выявлены и улажены
•Удовлетворение потребителя. Цель: Повышение эффективности пользователя, увеличение потребительской ценности продукта
•Управление выпуском. Цель: Беспроблемное внедрение и сопровождение продукта.
Можно выделить три направления, в которых осуществляется масштабирование проектной команды.
1. Создание групп направлений. Группы направлений (feature teams) - это компактные мини-команды, отвечающие за определенные компоненты создаваемого решения и образующие матричную организационную структуру. В них входят по одному или несколько членов из разных ролевых кластеров. Такие команды имеют четко определенную задачу и ответственны за все относящиеся к ней вопросы, начиная от планирования и кончая запуском в эксплуатацию.
2. Создание функциональных групп. Функциональные группы - это группы, существующие внутри ролевых кластеров. Они создаются в больших проектах, когда необходимо сгруппировать работников внутри ролевых кластеров по их областям компетенции
3. Объединение ролей (некоторые роли можно объединить, кроме разработчиков).
 
Фаза планирования
На фазе планирования (planning) производится основная работа по составлению планов проекта. Она включает в себя подготовку проектной группой функциональной спецификации, разработку дизайнов, подготовку рабочих планов, оценку проектных затрат и сроков разработки различных составляющих проекта.
Подготовка функциональной спецификации на систему включает в себя анализ и документирование проектных требований (выделяются: бизнес-требования, потребительские требования, эксплуатационные требования и системные требования, относящиеся к решению в целом). Задача предусматривает последовательное выполнение следующих работ:
· выявление типов пользователей системы;
· выявление сценариев использования, в которых моделируется выполнение какой-либо операции определенным типом пользователя;
· выделение последовательностей специфических действий, называемых примерами пользования (use cases), которые необходимо выполнить пользователю для осуществления операции;
· проектирование (дизайн системы). В MSF выделяется три уровня процесса проектирования: концептуальный дизайн (conceptual design), логический дизайн (logical design) и физический дизайн (physical design).
Концептуальный дизайн - описание всего, что нужно включить в конечный продукт. Концептуальный дизайн включает только подробные сведения о функциональности предлагаемого решения, взаимодействии с существующей технологической инфраструктурой, о пользовательском интерфейсе и предполагаемых рабочих характеристиках системы.
Логический дизайн - описание состава, организации и взаимодействия элементов, из которых состоит программное решение.
Физический дизайн - описание программного решения в терминах разработчика системы. Включает все необходимые детали для реализации: технологии, организацию, структуру и взаимосвязи элементов, которые будут использованы при создании программного решения.
Результаты процесса проектирования документируются в функциональной спецификации.

3. Организация ввода-вывода с использованием потоковых классов. Разработать иерархию классов
#include <iostream>
#include <fstream>
using namespace std;
class Figure {}; // абстрактный класс Фигура

class Rectangle : public Figure // класс Прямоугольник, унаследованный от класса Фигура
{
private:
double width;
double height;
public:
Rectangle() {} // конструктор
friend ostream& operator<<(ostream& os, const Rectangle& rect); // объявление дружественной функции перегрузки
friend istream& operator>>(istream& is, Rectangle& rect);
};

class Circle : public Figure // класс Окружность, унаследованный от класса Фигура
{
private:
double radius;
public:
Circle() { } // конструктор класса
friend ostream& operator<<(ostream& os, const Circle& circle); // объявление дружественной функции перегрузки
friend istream& operator>>(istream& is, Circle& circle);
};
ostream& operator<<(ostream& os, const Rectangle& rect) // перегрузка вывода
{
os << "Rectangle width = " << rect.width << ", Rectangle height = " << rect.height;
return os;
}
istream& operator>> (istream& is, Rectangle& rect) // перегрузка ввода
{
is >> rect.width >> rect.height;
return is;
}
ostream& operator<< (ostream& os, const Circle& circle) // перегрузка
{
os << "Circle radius = " << circle.radius;
return os;
}
istream& operator>> (istream& is, Circle& circle) // перегрузка ввода
{
is >> circle.radius;
return is;
}

int main() {
Rectangle rect;
cin >> rect;
cout << rect << endl;
Circle circle;
cin >> circle;
cout << circle << endl;

// файловый поток
fstream fout("file.txt", ios_base::in | ios_base::out); // создаём объект класса ofstream для записи и чтения, и связываем его с файлом file.txt
fout >> rect; // чтение информации о прямоугольнике из файла
fout >> circle; // чтение информации об окружности из файла
fout << rect << endl; // запись информации о прямоугольнике в файл
fout << circle; // запись информации об окружности в файл
fout.close(); // закрываем файл
return 0;
}

билет 3
1. Библиотека STL. Итераторы. Классы-контейнеры. 
STL – стандартная библиотека шаблонов. Обеспечивает стандартные классы и функции, которые реализуют широко используемые алгоритмы и структуры данных. STL строится на основе шаблонов классов, входящие в неё алгоритмы и структуры применимы ко всем типам данных. Ядро библиотеки образуют три элемента:
Контейнеры - это объекты, предназначенные для хранения набора элементов. Сущ два основных типа контейнеров: последовательности(имеет значение порядок следования элементов - stack, queue, vector) и ассоциативные контейнеры(map, set, multimap, multiset(неуникальные ключи)).
В каждом классе-контейнере определен набор функций для работы с ними.
методы для включения и исключения элементов:
insert(p, x) добавление х перед элементом, на который указывает р
push_back(),pop_back() - добавление/удаление в конец
push_front(x), pop_front() добавление/удаление первого элемента
Операции STL:
size() количество элементов empty() определяет, пуст ли контейнер capacity() память, выделенная под вектор (только для векторов)
Ассоциативные контейнеры.
 Ассоциативные контейнеры обеспечивают быстрый поиск данных, основанных на ключах.
Map - последовательность пар {ключ, значение},
В классе ассоциативного массива оператор V, возвращает ссылку на значение V, соответствующее ключу K.
#include <map> //подключили библиотеку для работы с map
int main() {
//Сделаем и инициализируем map
map <int,string> myFirstMap;
myFirstMap.insert(pair<int, string>(17, "abc"));
myFirstMap.insert(pair<int, string>(40, "afafaf"));
myFirstMap.insert(pair<int, string>(17, "sdfgj")); //не вставится!
for (auto it = myFirstMap.begin(); it != myFirstMap.end(); it++)
cout << it->first << " : " << it->second << endl;

Алгоритмы выполняют операции над содержимым контейнера. Например, алгоритмы для инициализации, сортировки, поиска, замены содержимого контейнеров.
Каждый алгоритм выражается шаблоном функции или набором шаблонов функций. Один и тот же алгоритм может работать с разными контейнерами, содержащими значения разнообразных типов.
Основные алгоритмы
for_each(); выполняет операции для каждого элемента последовательности
find(); находит первое вхождение значения в последовательность
count(); подсчитывает количество вхождений значения в последовательность
copy(); копирует последовательность, начиная с первого элемента
remove(); удаляет элементы с заданным значением
sort(); сортирует последовательность
merge(); сливает две отсортированные последовательности
min(); меньшее из двух значений
max(); большее из двух значений

Итераторы - это объекты, которые по отношению к контейнеру играют роль указателей. Они позволяют получить доступ к содержимому контейнера и сканировать его элементы (как указатели). Можно применять операции *, инкремент, декремент (существуют операторы ввода, вывода, однонаправленные, двунаправленные)
Итераторы:
	•	begin() указывает на первый элемент
	•	end() указывает на элемент, следующий за последним
	•	rbegin() указывает на первый элемент в обратной последовательности
	•	rend() указывает на элемент, следующий за последним в обратной последовательности
Вывод элементов вектора
vector <int> v;
vector <int>::iterator p;
for (p=v.begin(); p<v.end(); p++) cout << *p << " ";



2. Формирование команды. Стадия Внедрения
MSF(Microsoft Solutions Framework) – методология разработки программного обеспечения от компании Microsoft, опирающаяся на практический опыт компании и описывающая управление людьми и управление процессами в ходе разработки решения.
Методология MSF состоит из принципов, моделей и дисциплин по управлению персоналом, процессами.
Модель процессов включает такие основные фазы процесса разработки:
1. Выработка концепции (Envisioning)
2. Планирование (Planning)
3. Разработка (Developing)
4. Стабилизация (Stabilizing)
5. Внедрение (Deploying)
Формирование команды
Модель команды проекта MSF не предусматривает формирования какой-либо специальной организационной структуры или введения специальных должностей. Все работы выполняются представителями соответствующих ролевых кластеров.
Состав команды определяется теми целями, которые необходимо достичь для успеха проекта: за достижение конкретной цели отвечает соответствующий ролевой кластер, а за успешность проекта в целом несет ответственность вся команда. В соответствии с целями проекта MSF выделяет шесть ролевых кластеров:
1. Управление продуктом: (роль в кластере - бизнес-аналитик)
Цель: Удовлетворение Заказчиков.
2. Управление программой: (роль в кластере - менеджер проекта)
Цель: Достижение результата в рамках проектных ограничений
3. Разработка: (роль в кластере - разработчик)
Цель: Создание продукта в соответствии со спецификацией
4. Тестирование: (роль в кластере - тестер)
Цель: Одобрение выпуска продукта только лишь после того, как все дефекты выявлены и улажены
5. Удовлетворение потребителя: (роль в кластере - бизнес-аналитик)
Цель: Повышение эффективности пользователя, увеличение потребительской ценности продукта
6. Управление выпуском: (роль в кластере - релиз-менеджер)
Цель: Беспроблемное внедрение и сопровождение продукта
Можно выделить три направления, в которых осуществляется масштабирование проектной команды.
1. Создание групп направлений. Группы направлений - это компактные мини-команды, отвечающие за определенные компоненты создаваемого решения и образующие матричную организационную структуру. В них входят по одному или несколько членов из разных ролевых кластеров. 
2. Создание функциональных групп. Функциональные группы - это группы, существующие внутри ролевых кластеров. Они создаются в больших проектах, когда необходимо сгруппировать работников внутри ролевых кластеров по их областям компетенции. 
3. Объединение ролей. Зачастую в малых проектных группах члены группы могут объединять роли. При этом MSF рекомендует соблюдать два принципа: 
Во-первых, роль команды разработчиков не может быть объединена ни с какой другой ролью. 
Во-вторых, избежание сочетания ролей, имеющих предопределенные 
конфликты интересов.
Фаза внедрения
Цель фазы - установка и отладка системы в реальных условиях эксплуатации, стабилизация внедренного решения, передача системы персоналу поддержки и сопровождения, получение окончательного одобрения результатов проекта со стороны Заказчика.
Результатами этой фазы являются:
· информационные системы эксплуатации и поддержки;
· работающие процедуры и процессы;
· базы знаний, отчеты, журналы протоколов;
· версии проектных документов, массивы данных и программный код, разработанные во время проекта;
· отчет о завершении проекта;
· окончательные версии всех проектных документов;
· показатели удовлетворенности Заказчика и потребителей.

3. Разработка приложения с использованием иерархии наследования.

#include <iostream>
#include <algorithm>
using namespace std;

class Person{
protected:
    string firstName;
    string lastName;
    string patronymic;

public:
    Person (string firstName, string lastName, string patronymic) {
        this->firstName = firstName;
        this->lastName = lastName;
        this->patronymic = patronymic;
    }
    string getFirstName () {
        return (firstName);
    }
    string getLastName () {
        return (lastName);
    }
    string getPatronymic () {
        return (patronymic);
    }
    void setFirstName (string firstName) {
        this->firstName = firstName;
    }
    void setLastName (string lastName) {
        this->lastName = lastName;
    }
    void setPatronymic (string patronymic) {
        this->patronymic = patronymic;
    }
    virtual void printInfo () = 0;
};

class Employee : public Person{
protected:
    string department;
    float salary;

public:
    Employee (string firstName, string lastName, string patronymic, string department, float salary) :
    Person (firstName, lastName, patronymic) {
        this->department = department;
        this->salary = salary;
    }

    string getDepartment () {
        return (department);
    }
    float getSalary () {
        return (salary);
    }
    void setDepartment(string companyName) {
        this->department = department;
    }
    void setSalary(float salary){
        this->salary = salary;
    }
    virtual void printInfo () = 0;
};

//это класс, который наследуется от абстрактного класса Employee
class Teacher : public Employee {
protected:
    //Поле класса(модификатор protected)
    string scienceDegree;
public:
    Teacher (string firstName, string lastName, string patronymic, string department, float salary, string scienceDegree):
    Employee (firstName, lastName, patronymic, department, salary){
        this->scienceDegree = scienceDegree;
    }

    string getScienceDegree () {
        return (scienceDegree);
    }
    void setScienceDegree(string scienceDegree) {
        this->scienceDegree = scienceDegree;
    }
    void printInfo () {
        cout << "====== Teacher ======" << endl;
        cout << getScienceDegree() << ": " << getLastName () << " " << getFirstName () << " " << getPatronymic                    () << endl;
        cout << getDepartment () << endl;
        cout << getSalary () << endl;
        cout << "======" << endl;
    }
    //переопределяем оператор “меньше”(нужно для сортировки)
    bool operator<(Teacher & t) {
        return salary < t.getSalary();
   }
};
class Student : public Person{
protected:
    int course;
    string speciality;

public:
    Student (string firstName, string lastName, string patronymic, int course, string speciality):
    Person (firstName, lastName, patronymic) {
        this->course = course;
        this->speciality = speciality;
    }
    string getSpeciality () {
        return (speciality);
    }
    int getCourse () {
        return (course);
    }
    void setSpeciality(string speciality) {
        this->speciality = speciality;
    }
    void setCourse(int course){
        this->course = course;
    }
    void printInfo () {
        cout << "====== Student ======" << endl;
        cout << getLastName () << " " << getFirstName () << " " << getPatronymic () << endl;
        cout << "Course: " << getCourse() << endl;
        cout << "Speciality: " << getSpeciality() << endl;
        cout << "======" << endl;
    }
    bool operator<(Student & s) {
        return this->getCourse() < s.getCourse();
        }
};

Person* findByFirstName(string firstName, Person* persons[], int n){
    for (int i = 0; i < n; i++){
        if(persons[i]->getFirstName() == firstName){
            return persons[i];
        }
    }
}

bool personGreater(Person* p1, Person* p2 ) {
    return p1->getFirstName() > p2->getFirstName();
}

int main (int argc, const char *argv[]) {
Teacher t("Иван", "Иванов", "Иванович", "ИТАС", 100, "Доцент");
Student s("Петр", "Петров", "Петрович", 4, "РИС");
Person * persons[2];
persons[0] = &s;
persons[1] = &t;  
findByFirstName("Петр", persons, 2)->printInfo();
sort(persons, persons + 2, personGreater);
return (0);
}






Билет 4
1. Потоковые классы. Библиотека потоковых классов
Поток — это общее название потока данных. В C++ поток представляет собой объект некоторого класса.
Библиотека потоковых классов С++ построена на основе двух базовых классов: ios и streambuf .
Класс streambuf обеспечивает организацию и взаимосвязь буферов ввода-вывода, размещаемых в памяти, с физическими устройствами ввода-вывода. Методы и данные класса streambuf программист явно обычно не использует. Этот класс нужен другим классам библиотеки ввода-вывода.
Класс ios является базовым для всей иерархии. Он содержит множество констант и методов, общих для операций ввода/ вывода любых видов.

Стандартные потоки ввода/вывода
Чтобы использовать стандартные потоки ввода-вывода нужно включать заголовочный файл <iostream.h>, который наследуется от класса ios.

Поток вывода cout.
С помощью потока cout можно выводить на экран значения переменных, символьные литералы, строковые литералы, значения выражений и результаты выполнения функций. При этом переменные и выражения записываются в качестве второго аргумента оператора << записываются просто так, строковые литералы - в двойных кавычках "пример", а символьные - в одинарных 'пример'.
cout << "Значение переменной i равно " << i << '\n';
Поток ввода cin.
Для считывания информации, вводимой пользователем с клавиатуры, служит стандартный поток cin. Как и поток вывода, поток ввода работает с символьным представлением типов. То, как будут интерпретироваться вводимые символы, зависит от второго аргумента оператора >> (того, что справа). Соответственно, вам не нужно указывать, какого типа данные предполагается считать, компилятор определит это исходя из типа переменной.
int a;
cin >> a;

Форматирование
Есть несколько способов установки флагов форматирования, для каждого свои. Так как они являются компонентами класса ios, обычно к ним обращаются посредством написания имени класса и оператора явного задания (например, ios::skipws(skipws это пропуск пробелов при вводе)). Все без исключения флаги могут быть выставлены с помощью методов setf() и unsetf(). Примеры:
cout.setf(ios::left); // выравнивание текста по левому краю
cout << "Этот текст выровнен по левому краю";

2. Стадия Разработки. Стадия Стабилизации
Microsoft Solutions Framework (MSF) -методология разработки программного обеспечения, предложенная корпорацией Microsoft. MSF опирается на практический опыт Microsoft и описывает управление людьми и рабочими процессами в процессе разработки решения.
MSF представляет собой согласованный набор концепций, моделей и правил.
Модель процессов включает такие основные фазы процесса разработки:
· Выработка концепции (Envisioning)
· Планирование (Planning)
· Разработка (Developing)
· Стабилизация (Stabilizing)
· Внедрение (Deploying)
Фаза разработки
На фазе разработки проектная группа фокусируется на создании компонент решения (включая как документацию, так и программный код). Однако некоторая часть этой работы может продолжаться также на фазе стабилизации, если такая необходимость выявлена в процессе тестирования. Данная фаза также включает в себя разработку инфраструктуры.
Фаза стабилизации
Во время фазы стабилизации производится тестирование разработанного решения. При этом внимание фокусируется на его эксплуатации в реалистичной модели производственной среды. Проектная группа занимается приоритезацией и устранением ошибок, а также подготовкой решения к выпуску.
Обычно в начале фазы стабилизации скорость выявления ошибок командой тестирования превосходит скорость, с которой эти ошибки могут устраняться командой разработчиков. Невозможно предсказать, сколько ошибок будет найдено и как много времени понадобится на их устранение. Однако существует два статистических признака, помогающих проектной группе оценить уровень стабилизации решения. Это точка конвергенции (bug convergence) и точка достижения нуля ошибок (zero bug bounce).
Точка конвергенции – становится заметен существенный прогресс в устранении ошибок, то есть скорость устранения ошибок начинает превосходить скорость их обнаружения.
Точка достижения нуля ошибок – это момент, когда впервые все выявленные ошибки оказываются устраненными.
3. - найти города, названия которых начинается на латинскую букву ‘A’. 

SELECT DISTINCT Country.Name 
FROM Country 
JOIN City ON Country.Code = City.CountryCode
WHERE City.Name LIKE 'A%';

билет 5
1. Реляционная модель данных.

Реляционная модель данных - логическая модель данных. Создана Э. Коддом в 60-70 годах 20 века.

Это совокупность данных, состоящая из набора двумерных таблиц. При табличной организации данных отсутствует иерархия элементов. 
На реляционной модели данных строятся реляционные базы данных и большинство современных СУБД. Строки и столбцы могут быть просмотрены в любом порядке, отсюда гибкость выборки элементов.

Структура:
	•	каждая строка - запись
	•	каждый столбец - поле. Для каждого поля определяется множество его значений.
	•	ключевое поле - значение которого однозначно идентифицирует каждую запись (уникальное)

Структура таблицы характеризуется:
	•	совокупностью столбцов
	•	уникальным именем столбца
	•	последовательность строк и столбцов несущественна
	•	все строки организованы по одинаковой структуре
	•	количество строк не ограничено

Кроме первичного ключа в таблице могут быть вторичные ключи, называемые еще внешними ключами, или индексами. Индекс – это поле или совокупность полей, чьи значения имеются в нескольких таблицах и которое является первичным ключом в одной из них. Значения индекса могут повторяться в некоторой таблице. Индекс обеспечивает логическую последовательность записей в таблице, а также прямой доступ к записи.

Индексы можно создавать и удалять. Индексы позволяют эффективно реализовать поиск и обработку данных, формируя дополнительные индексные файлы. При корректировке данных автоматически упорядочиваются индексы, изменяется местоположение каждого индекса согласно принятому условию (возрастанию или убыванию значений). Сами же записи реляционной таблицы не перемещаются при удалении или включении новых экземпляров записей, изменении значений их ключевых полей.
С помощью индексов и ключей устанавливаются связи между таблицами. Связь устанавливается путем присвоения значений внешнего ключа одной таблицы значениям первичного ключа другой. Группа связанных таблиц называется схемой данных. Информация о таблицах, их полях, ключах и т.п. называется метаданными.

Достоинства 
	•	Изложение информации в простой и понятной для пользователя форме (таблица). 
	•	Реляционная модель данных основана на строгом математическом аппарате, что позволяет лаконично описывать необходимые операции над данными. 
	•	Независимость данных от изменения в прикладной программе при изменении. 
	•	Для работы с моделью данных нет необходимости полностью знать организацию БД.
 Недостатки 
	•	Относительно медленный доступ к данным. 
	•	Трудность в создании БД основанной на реляционной модели. 
	•	Трудность в переводе в таблицу сложных отношений. 
	•	Требуется относительно большой объем памяти.

2. Понятие ооп. Основные принципы: наследование и полиморфизм.
(ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования
При объектно-ориентированном подходе к программированию программа представляет собой совокупность взаимодействующих между собой данных — объектов. Функциональную возможность и структуру объектов задают классы — типы данных, определенные пользователем. При рассмотрении объектов выделяется то, что объекты принадлежат одному или нескольким классам, которые определяют поведение (являются моделью) объекта. классы могут задавать поля .
Поля класса являются переменными, объявленными внутри класса. Они предназначены для хранения данных во время работы экземпляра класса (объекта). В описании класса поля должны предшествовать методам и свойствам. Обычно поля используются для обеспечения выполнения операций внутри класса.
Для получения и передачи данных в классе применяются 
Свойства. Свойства представляют собой атрибуты, которые составляют индивидуальность объекта и помогают описать его. Так как свойство обеспечивает обмен данными с внешней средой, то для доступа к его значению используются специальные Методы класса. Поэтому обычно свойство определяется тремя элементами: полем и двумя методами, которые осуществляют его чтение/запись
ООП основано на «трех китах» - трех важнейших принципах, придающих объектам новые свойства. Этими принципами являются инкапсуляция, наследование и полиморфизм.
Особенностью ООП является поощрение повторного использования кода при помощи механизма наследования. Новый класс производится от существующего, называемого базовым классом. Производный класс использует члены базового класса, но может также изменять и дополнять их.
В (ООП) существуют два различных типа наследования: наследование реализации и наследование интерфейса.
1. Наследование реализации означает, что тип происходит от базового типа, получая от него все поля-члены и функции-члены. При наследовании реализации производный тип адаптирует реализацию каждой функции базового типа, если только в его определении не указано, что реализация функции должна быть переопределена. Такой тип наследования более полезен, когда нужно добавить функциональность к существующему типу или же когда несколько связанных типов разделяют существенный объем общей функциональности.
2. Наследование интерфейса означает, что тип наследует только сигнатуру функций, но не наследует никакой реализации. Этот тип наследования наиболее полезен, когда нужно специфицировать, что тип обеспечивает доступ к определенным средствам. (наследование реализации - это и есть наследование.Наследование интерфейса - это реализация интерфейса или абстрактных методов абстрактного класса.)
Интерфейс — Специальные классы, описывающие совокупность методов и правил взаимодействия элементов системы,но не имеющие данных и реализации.Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой. 
Клонирование объекта - это создание еще одного экземпляра класса, идентичного данному объекту. Для этого используется специальное ключевое слово clone, после которого необходимо указать объект, который будет клонирован. Эта конструкция вернет новый экземпляр класса. Таким образом можно получить новый экземпляр класса по существующему объекту. При этом, в новый объект будут записаны те значения свойств, которые там были на момент клонирования.
Множественное наследование— наследование от нескольких базовых классов одновременно. Синтаксически множественное наследование почти не отличается от обычного.( class 12: public 1, public 2{}; )
Полиморфи́зм — возможность объектов с одинаковой спецификацией иметь различную реализацию. (возможность использовать одинаковые имена для методов, входящих в различные классы.) virtual для базового, override для след.
Язык программирования поддерживает полиморфизм, если классы с одинаковой спецификацией могут иметь различную реализацию — например, реализация класса может быть изменена в процессе наследования

Абстрактные классы предназначены для создания обобщенных  сущностей, на основе которых в дальнейшем предполагается создавать более конкретные производные классы. Абстрактный класс – это класс, который может использоваться лишь в качестве базового класса для некоторого другого класса, поэтому невозможно создать объект типа абстрактного класса

3. найти страны, где продолжительность жизни превосходит Россию;
SELECT Name, LifeExpectancy 
FROM Country 
WHERE LifeExpectancy > (SELECT LifeExpectancy 
FROM country 
WHERE name = "Russian Federation")
билет 6
1. Метод «сущность – связь». Основные понятия метода
Модель "сущность-связь" основывается на некой важной семантической информации о реальном мире и предназначена для логического представления данных. Определяет значения данных в контексте их взаимосвязи с другими данными. Из модели "сущность-связь" могут быть порождены все существующие модели данных (иерархическая, сетевая, реляционная, объектная).
Сущность представляет собой объект, информация о котором хранится в БД. Экземпляры сущности отличаются друг от друга и однозначно идентифицируются.
Названиями сущностей являются, как правило, существительные, например: ПРЕПОДАВАТЕЛЬ, ДИСЦИПЛИНА, КАФЕДРА, ГРУППА.

Атрибут - свойство сущности. Понятие аналогично понятию атрибута в отношении. Так, атрибутами сущности ПРЕПОДАВАТЕЛЬ могут быть Фамилия, Должность, Стаж.
Ключ сущности — атрибут или набор атрибутов, используемый для идентификации экземпляра сущности. Понятие ключа сущности аналогично понятию ключа отношения.
Степень связи является характеристикой связи между сущностями, которая может быть типа: 1:1,1: М, М:1, М: М.
Класс принадлежности сущности может быть: обязательным и необязательным. Класс принадлежности сущности является обязательным, если все экземпляры этой сущности обязательно участвуют в рассматриваемой связи, в противном случае -необязательным.
Пример 1. Связи типа 1:1; класс принадлежности обеих сущностей необязательный.
Каждый преподаватель ведет не более одной дисциплины, а каждая дисциплина ведется не более чем одним преподавателем; некоторые преподаватели не ведут ни одной дисциплины и имеются дисциплины, которые не ведет ни один из преподавателей.
Пример 2. Связи типа 1:1, класс принадлежности обеих сущностей обязательный.
Каждый преподаватель ведет одну дисциплину, и каждая дисциплина ведется одним преподавателем.
Пример 3. Связи типа 1: М. Каждый преподаватель может вести несколько дисциплин, но каждая дисциплина ведется одним преподавателем.
Пример 4. Связи типа М:1. Каждый преподаватель может вести одну дисциплину, но каждую дисциплину могут вести несколько преподавателей.
Пример 5. Связи типа 1: М вариант Н-О. Каждый преподаватель может вести несколько дисциплин или ни одной, но каждая дисциплина ведется одним преподавателем.
Пример 6. Связи типа М: М. Каждый преподаватель может вести несколько дисциплин, а каждая дисциплина может вестись несколькими преподавателями.
Пример 7. Связи типа М: М и вариант класса принадлежности О-Н. Допустим, что каждый преподаватель ведет не менее одной дисциплины, а дисциплина может вестись более чем одним преподавателем, есть и такие дисциплины, которые никто не ведет.

2. Расстановка приоритетов исполнения проекта. Структурирование работ по этапам
Упорядоченный подход к сбору информации по проекту, необходимой для планирования, составления графика работ и контроля за выполнением проекта, обеспечивают пять типовых этапов, приводимых ниже.
	•	ЭТАП 1: разработка технического задания.
	•	ЭТАП 2: расстановка приоритетов.
	•	ЭТАП 3: структурирование работ по этапам.
	•	ЭТАП 4: совмещение структуры распределения работы по этапам (СРРПЭ) с организацией.
	•	ЭТАП 5: кодирование СРРПЭ для информационной системы.
Разработка технического задания на проект. Техническое задание - это определение конечного результата или цели вашего проекта - товара или услуги для вашего заказчика. Основной целью здесь является как можно более четкое определение промежуточных результатов работы для конечного пользователя и концентрация (в единое целое) планов проекта.
ТЗ должно разрабатываться под руководством управляющего проектом и клиента. Управляющий проектом должен согласовывать с заказчиком цели, промежуточные результаты работы на каждой стадии проекта, технические требования и т.д.
Техническое задание - это документ, который будет соответственно оформлен и использован владельцем проекта и участниками проекта для планирования и измерения успеха проекта. ТЗ объясняет, какую продукцию вы поставите своему клиенту по завершении проекта. ТЗ проекта должно представлять намеченные результаты в конкретном и поддающемся измерению виде.
ТЗ включает в себя:
1. Цели проекта.
2. Промежуточные результаты работы.
3. Контрольные точки.
4. Технические требования.
5. Ограничения и исключения.
6. Проверка выполнения работы совместно с клиентом.
Расстановка приоритетов
Одной из основных задач управляющего проектом является управление соотношением между временем, стоимостью и результативностью.
Матрица приоритетов проекта

Структурирование работ по этапам.
Работу над проектом можно разделить на более мелкие элементы.
Результат этого поэтапного процесса называется структурой распределения работы по этапам (СРРПЭ).
Этапы:
1. Проект – проект в целом.
2. Промежуточный результат – основные промежуточные результаты работы.
3. Предварительный результат – промежуточные результаты работы, на которые опираются остальные.
4. Элементарный результат – самый нижний уровень ответственности менеджеров.
5. Учет издержки – группировка работ в задании для отслеживания хода работ и учета ответственности.
6. Рабочее задание – отличаемые виды работ.
Каждый набор работ в СРРПЭ:
1. Определяет, какая работа будет выполняться (что).
2. Указывает время выполнения набора работ (как долго).
3. Определяет смету с учетом времени на выполнение набора работ (стоимость).
4. Определяет ресурсы, необходимые для выполнения набора работ (сколько).
5. Определяет контрольные пункты для измерения хода выполнения.

3. Проектирование иерархии классов. Определить абстрактный класс. Определить иерархию классов, в основе которой будет находиться абстрактный класс.
#include <iostream>
using namespace std;
class Figure // абстрактный класс Фигура
{
public:
// виртуальные функции
virtual double getSquare() =0;
virtual double getPerimeter() =0;
};

class Rectangle : public Figure // класс Прямоугольник, унаследованный от класса Фигура
{
private:
double width;
double height;
public:
Rectangle(double w, double h) : width(w), height(h) { } // конструктор
double getSquare() override // переопределение функции площади
{
return width * height;
}
double getPerimeter() override // переопределение функции периметра
{
return width * 2 + height * 2;
}
};

class Circle : public Figure // класс Окружность, унаследованный от класса Фигура
{
private:
double radius;
public:
Circle(double r) : radius(r) { } // конструктор класса
double getSquare() override // переопределение функции площади
{
return radius * radius * 3.14;
}
double getPerimeter() override // переопределение функции периметра
{
return 2 * 3.14 * radius;
}
};

int main() {
Rectangle rect(30, 50);
Circle circle(30);
cout << "Rectangle square: " << rect.getSquare() << endl;
cout << "Rectangle perimeter: " << rect.getPerimeter() << endl;
cout << "Circle square: " << circle.getSquare() << endl;
cout << "Circle perimeter: " << circle.getPerimeter() << endl;
return 0;
}

билет 7
1.  Стадия Разработки. Стадия Стабилизации
Microsoft Solutions Framework (MSF) -методология разработки программного обеспечения, предложенная корпорацией Microsoft. MSF опирается на практический опыт Microsoft и описывает управление людьми и рабочими процессами в процессе разработки решения.
MSF представляет собой согласованный набор концепций, моделей и правил.
Модель процессов включает такие основные фазы процесса разработки:
· Выработка концепции (Envisioning)
· Планирование (Planning)
· Разработка (Developing)
· Стабилизация (Stabilizing)
· Внедрение (Deploying)
Фаза разработки
На фазе разработки проектная группа фокусируется на создании компонент решения (включая как документацию, так и программный код). Однако некоторая часть этой работы может продолжаться также на фазе стабилизации, если такая необходимость выявлена в процессе тестирования. Данная фаза также включает в себя разработку инфраструктуры.
Фаза стабилизации
Во время фазы стабилизации производится тестирование разработанного решения. При этом внимание фокусируется на его эксплуатации в реалистичной модели производственной среды. Проектная группа занимается приоритезацией и устранением ошибок, а также подготовкой решения к выпуску.
Обычно в начале фазы стабилизации скорость выявления ошибок командой тестирования превосходит скорость, с которой эти ошибки могут устраняться командой разработчиков. Невозможно предсказать, сколько ошибок будет найдено и как много времени понадобится на их устранение. Однако существует два статистических признака, помогающих проектной группе оценить уровень стабилизации решения. Это точка конвергенции (bug convergence) и точка достижения нуля ошибок (zero bug bounce).
Точка конвергенции – становится заметен существенный прогресс в устранении ошибок, то есть скорость устранения ошибок начинает превосходить скорость их обнаружения.
Точка достижения нуля ошибок – это момент, когда впервые все выявленные ошибки
2. Перегрузка операций. Перегрузка унарных и бинарных операций.
Правила перегрузки операций
	•	Язык C++ не допускает определения для операций нового лексического символа, кроме уже определенных в языке. Например, нельзя определить в качестве знака операции @.
	•	Не допускается перегрузка операций для встроенных типов данных.
	•	Нельзя переопределить приоритет операции.
	•	Нельзя изменить синтаксис операции в выражении. Например, если некоторая операция определена как унарная, то ее нельзя определить как бинарную. Если для операции используется префиксная форма записи, то ее нельзя переопределить в постфиксную. Например, !а нельзя переопределить как а!
	•	Перегружать можно только операции, для которых хотя бы один аргумент представляет тип данных, определенный пользователем. Функция-операция должна быть определена либо как функция-член класса, либо как внешняя функция, но дружественная классу.

Функция- член класса 
class String
{ …
public:
  String operator + (const String&);
…};

Дружественная функция
class String
 { … 
public: 
  friend String operator +(String &, String &);
…};
Перегрузка унарных операций
Любая унарная операция @ может быть определена двумя способами: либо как компонентная функция без параметров, либо как глобальная (возможно дружественная) функция с одним параметром. В первом случае выражение @ Z означает вызов Z.operator @(), во втором - вызов operator @(Z).
Унарные операции, перегружаемые в рамках определенного класса, могут перегружаться только через нестатическую компонентную функцию без параметров. Вызываемый объект класса автоматически воспринимается как операнд.
Унарные операции, перегружаемые вне области класса (как глобальные функции), должны иметь один параметр типа класса. Передаваемый через этот параметр объект воспринимается как операнд.
Перегрузка бинарных операций
Любая бинарная операция @ может быть определена двумя способами: либо как компонентная функция с одним параметром, либо как глобальная (возможно дружественная) функция с двумя параметрами. В первом случае x @ y означает вызов x.operator @(y), во втором – вызов operator @(x, y).
Операции, перегружаемые внутри класса, могут перегружаться только нестатическими компонентными функциями с параметрами. Вызываемый объект класса автоматически воспринимается в качестве первого операнда.
Операции, перегружаемые вне области класса, должны иметь два операнда, один из которых должен иметь тип класса.
Операции инкремента и декремента
Унарные операции инкремента ++ и декремента -- существуют в двух формах: префиксной и постфиксной. В современной спецификации С++ определен способ, по которому компилятор может различить эти две формы. В соответствии с этим способом задаются две версии функции operator ++() и operator --().
Перегрузка операции присваивания
Операция отличается тремя особенностями:
	•	операция не наследуется;
	•	операция определена по умолчанию для каждого класса в качестве операции поразрядного копирования объекта, стоящего справа от знака операции, в объект, стоящий слева.
	•	операция может перегружаться только в области определения класса. Это гарантирует, что первым операндом всегда будет леводопустимое выражение.

3. Используя язык SQL написать запрос для таблицы Table1 с атрибутами ID и DATETIME

SELECT max(ID) as max_id, `DATETIME`  FROM Table1 WHERE max_id = ID;


билет 8
1. Оператор SQL– SELECT (выборка). Предложения FROM, WHERE
SELECT – оператор запроса, возвращающий набор данных из базы данных.

SELECT [DISTINCT | ALL] <выражение для столбца | *> AS <псевдоним>э
FROM <имя таблицы> AS <псевдоним>
WHERE <предикат>
GROUP BY <список столбцов>
HAVING <условие на агрегатные значения>
ORDER BY <список столбцов>

Выборка может содержать дубликаты строк. Если требуется получить уникальные строки, то можно использовать ключевое слово DISTINCT или ALL для всех строк (по умолчанию).
Предложение WHERE <предикат> реализует горизонтальную выборку. При этом в результирующий набор попадут только те строки из источника записей, для каждой из которых значение предиката равно TRUE.
Агрегатные функции
COUNT(*)
Возвращает количество строк источника записей.
COUNT(<имя поля>)
Возвращает количество значений в указанном столбце.
SUM(<имя поля>) 
Возвращает сумму значений в указанном столбце.
AVG(<имя поля>)
Возвращает среднее значение в указанном столбце.
MIN(<имя поля>)
Возвращает минимальное значение в указанном столбце.
MAX(<имя поля>) 
Возвращает максимальное значение в указанном столбце.

Предложение GROUP BY используется для объединения результатов выборки по одному или нескольким столбцам.
Если запрос не содержит предложения GROUP BY, то агрегатные функции, включенные в предложение SELECT, исполняются над всеми результирующими строками запроса. Если запрос содержит предложение GROUP BY, каждый набор строк, который имеет одинаковые значения столбца или группы столбцов, заданных в предложении GROUP BY, составляет группу, и агрегатные функции выполняются для каждой группы отдельно.

Предложение HAVING применяется для фильтрации группировки (для проверки значений, которые получены с помощью агрегатной функции не из отдельных строк источника записей, определенного в предложении FROM, а из групп таких строк).
SELECT model, COUNT(model), AVG(price) 
FROM PC 
GROUP BY model 
HAVING AVG(price) < 800;

Чтобы упорядочить строки выборки, можно выполнить сортировку по любому количеству полей, указанных в предложении SELECT. Для этого используется предложение ORDER BY <список полей>, являющееся всегда последним предложением в операторе SELECT. При этом в списке полей могут указываться как имена полей, так и их порядковые позиции в списке предложения SELECT.

SELECT DISTINCT speed, ram 
FROM Pc 
ORDER BY ram 
DESC
Сортировку можно проводить по возрастанию (параметр ASC принимается по умолчанию) или по убыванию (параметр DESC).

2. Формирование команды. Стадия Выработки концепции
MSF(Microsoft Solutions Framework) – методология разработки программного обеспечения от компании Microsoft, опирающаяся на практический опыт компании и описывающая управление людьми и управление процессами в ходе разработки решения.
Методология MSF состоит из принципов, моделей и дисциплин по управлению персоналом, процессами.
Модель процессов включает такие основные фазы процесса разработки:
1. Выработка концепции (Envisioning)
2. Планирование (Planning)
3. Разработка (Developing)
4. Стабилизация (Stabilizing)
5. Внедрение (Deploying)
Формирование команды
Все работы выполняются представителями соответствующих ролевых кластеров.
Состав команды определяется теми целями, которые необходимо достичь для успеха проекта: за достижение конкретной цели отвечает соответствующий ролевой кластер, а за успешность проекта в целом несет ответственность вся команда. В соответствии с целями проекта MSF выделяет шесть ролевых кластеров:
1. Управление продуктом: (роль в кластере - бизнес-аналитик)
Цель: Удовлетворение Заказчиков.
2. Управление программой: (роль в кластере - менеджер проекта)
Цель: Достижение результата в рамках проектных ограничений
3. Разработка: (роль в кластере - разработчик)
Цель: Создание продукта в соответствии со спецификацией
4. Тестирование: (роль в кластере - тестер)
Цель: Одобрение выпуска продукта только лишь после того, как все дефекты выявлены и улажены
5. Удовлетворение потребителя: (роль в кластере - бизнес-аналитик)
Цель: Повышение эффективности пользователя, увеличение потребительской ценности продукта
6. Управление выпуском: (роль в кластере - релиз-менеджер)
Цель: Беспроблемное внедрение и сопровождение продукта
Можно выделить три направления, в которых осуществляется масштабирование проектной команды.
1. Создание групп направлений. Группы направлений - это компактные мини-команды, отвечающие за определенные компоненты создаваемого решения и образующие матричную организационную структуру. В них входят по одному или несколько членов из разных ролевых кластеров. 
2. Создание функциональных групп. Функциональные группы - это группы, существующие внутри ролевых кластеров. Они создаются в больших проектах, когда необходимо сгруппировать работников внутри ролевых кластеров по их областям компетенции. 
3. Объединение ролей. Зачастую в малых проектных группах члены группы могут объединять роли. При этом MSF рекомендует соблюдать два принципа: 
Во-первых, роль команды разработчиков не может быть объединена ни с какой другой ролью. 
Во-вторых, избежание сочетания ролей, имеющих предопределенные 
конфликты интересов.
Фаза выработки концепции (envisioning)
Цель - создание и сплочение проектной группы на основе выработки единого видения. Проектная группа должна четко представить себе, что она хочет сделать для заказчика и сформулировать свою цель таким образом, чтобы максимально мотивировать как заказчика, так и саму проектную команду.
Основные выполняемые задачи:
· создание ядра проектной группы;
· подготовка документа общего описания (Видение) и рамок проекта (vision / scope document). Видение (vision) - это ничем не ограничиваемое представление о том, каким должно быть решение. Рамки (scope) - определение того, что из предложенного этим видением будет реализовано в условиях существующих проектных ограничений.
· определение и оценка главных рисков проекта;
· выявление и первичный анализ бизнес требований (детально эти требования рассматриваются во время фазы планирования).
Результаты выполнения фазы фиксируются в ряде документов:
· общее описание и рамки проекта;
· документ оценки рисков;
· описание структуры проекта.

3. Использование классов и алгоритмов стандартной библиотеки шаблонов. Создать контейнер из библиотеки STL.
	•	Последовательные контейнеры (vector, list, deque)
	•	Ассоциативные контейнеры (set, multiset, map, multimap)
	•	Контейнеры-адаптеры (stack, queue, priority_queue)







Пример создадим вектор в который добавим/изменим/удалим значения элементов и отсортируем его.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
vector <int> vec = {1, 2, 3, 4, 5}; // создадим контейнер вектор и заполним его

vec.push_back(9); // Вставим в конец вектора число 9
vec.pop_back(); // Удалим последний элемент вектора
vec.insert(vec.begin()+1,2,6); // Вставим после 1 элемента две шестерки
vec.erase(vec.begin()+1); // удалим 2 элемент
vec.at(0) = 7; // Изменим первый элемент на 7
for_each(vec.begin(), vec.end(), [] (int &n){ n++; }); //Применяет функцию for_each в которой мы все элементы вектора увеличиваем на 1
sort(vec.begin(), vec.end()); // Сортирует вектор по возрастанию
for(int i = 0; i<vec.size();i++) //выводим вектор на экран
cout << vec[i] << endl;
return 0;
}


билет 9
1. Шаблоны функций и классов. Шаблоны функций. Шаблоны классов. 
Любой шаблон начинается со слова template, будь то шаблон функции или шаблон класса. После ключевого слова template идут угловые скобки — < >, в которых перечисляется список параметров шаблона. Каждому параметру должно предшествовать зарезервированное слово class или typename.
template<typename T>
T — это даже не тип данных, это зарезервированное место под любой встроенный тип данных. То есть когда выполняется вызов этой функции, компилятор анализирует параметр шаблонизированной функции и создает экземпляр для соответствующего типа данных: int, char и так далее.
К примеру Stack<T>. В стэк мы можем положить элементы любого типа данных.

Компонентная функция - функция, которая описана в теле класса и имеет доступ ко всем компонентам класса (в этом случае template <typename T> не используется). При внешнем определении компонентной функции программист «должен сообщить» компилятору, к какому именно классу она относится (определение класса должно содержать прототипы этих функций, а заголовок функции должен включать описатель видимости, который состоит из имени класса и знака «::»).
void Stack<T>::printStack()

Инстанцирование
В С++ это процесс, при котором на основе обобщенного определения шаблонов генерируются типы и функции. Инстанцирование происходит с проверкой типов данных (совместимость по присваиванию, совместимость по приведению типов). Может производиться явно или неявно для функций, всегда явно для классов.

Пример явного инстанцирования:
template <typename T> //Шаблон функции «Модуль»
T abs (T x) {
if (x<0) {
return –x;
}
return x;
}

Int main() {
sout << abs<int>(-5.5); // явное инстанцирование
}

2. Формирование команды. Стадия Планирования
Microsoft Solutions Framework (MSF)-методология разработки программного обеспечения, предложенная корпорацией Microsoft. MSF опирается на практический опыт Microsoft и описывает управление людьми и рабочими процессами в процессе разработки решения. 
MSF представляет собой согласованный набор концепций, моделей и правил.
Модель процессов включает такие основные фазы процесса разработки:
· Выработка концепции (Envisioning)
· Планирование (Planning)
· Разработка (Developing)
· Стабилизация (Stabilizing)
· Внедрение (Deploying)
Формирование команды
Модель команды проекта MSF не предусматривает формирования какой-либо специальной организационной структуры или введения специальных должностей. Все работы выполняются представителями соответствующих ролевых кластеров.
Состав команды определяется теми целями, которые необходимо достичь для успеха проекта: за достижение конкретной цели отвечает соответствующий ролевой кластер, а за успешность проекта в целом несет ответственность вся команда. В соответствии с целями проекта MSF выделяет шесть ролевых кластеров, каждый из которых должен обладать специфическими компетенциями для исполнения собственных функций:
• Управление продуктом. Цель: Удовлетворение Заказчиков.
• Управление программой. Цель: Достижение результата в рамках проектных ограничений.
•Разработка. Цель: Создание продукта в соответствии со спецификацией.
• Тестирование. Цель: Одобрение выпуска продукта только лишь после того, как все дефекты выявлены и улажены
•Удовлетворение потребителя. Цель: Повышение эффективности пользователя, увеличение потребительской ценности продукта
•Управление выпуском. Цель: Беспроблемное внедрение и сопровождение продукта.
Можно выделить три направления, в которых осуществляется масштабирование проектной команды.
1. Создание групп направлений. Группы направлений (feature teams) - это компактные мини-команды, отвечающие за определенные компоненты создаваемого решения и образующие матричную организационную структуру. В них входят по одному или несколько членов из разных ролевых кластеров. Такие команды имеют четко определенную задачу и ответственны за все относящиеся к ней вопросы, начиная от планирования и кончая запуском в эксплуатацию.
2. Создание функциональных групп. Функциональные группы - это группы, существующие внутри ролевых кластеров. Они создаются в больших проектах, когда необходимо сгруппировать работников внутри ролевых кластеров по их областям компетенции
3. Объединение ролей (некоторые роли можно объединить, кроме разработчиков).
 
Фаза планирования
На фазе планирования (planning) производится основная работа по составлению планов проекта. Она включает в себя подготовку проектной группой функциональной спецификации, разработку дизайнов, подготовку рабочих планов, оценку проектных затрат и сроков разработки различных составляющих проекта.
Подготовка функциональной спецификации на систему включает в себя анализ и документирование проектных требований (выделяются: бизнес-требования, потребительские требования, эксплуатационные требования и системные требования, относящиеся к решению в целом). Задача предусматривает последовательное выполнение следующих работ:
· выявление типов пользователей системы;
· выявление сценариев использования, в которых моделируется выполнение какой-либо операции определенным типом пользователя;
· выделение последовательностей специфических действий, называемых примерами пользования (use cases), которые необходимо выполнить пользователю для осуществления операции;
· проектирование (дизайн системы). В MSF выделяется три уровня процесса проектирования: концептуальный дизайн (conceptual design), логический дизайн (logical design) и физический дизайн (physical design).
Концептуальный дизайн - описание всего, что нужно включить в конечный продукт. Концептуальный дизайн включает только подробные сведения о функциональности предлагаемого решения, взаимодействии с существующей технологической инфраструктурой, о пользовательском интерфейсе и предполагаемых рабочих характеристиках системы.
Логический дизайн - описание состава, организации и взаимодействия элементов, из которых состоит программное решение.
Физический дизайн - описание программного решения в терминах разработчика системы. Включает все необходимые детали для реализации: технологии, организацию, структуру и взаимосвязи элементов, которые будут использованы при создании программного решения.
Результаты процесса проектирования документируются в функциональной спецификации.
3. - найти количество городов в каждой стране;
SELECT Country.Name, count(City.ID) FROM Country JOIN City ON Country.Code = City.CountryCode GROUP BY Country.Name;


билет 10
1. Формирование команды. Стадия Внедрения
MSF(Microsoft Solutions Framework) – методология разработки программного обеспечения от компании Microsoft, опирающаяся на практический опыт компании и описывающая управление людьми и управление процессами в ходе разработки решения.
Методология MSF состоит из принципов, моделей и дисциплин по управлению персоналом, процессами.
Модель процессов включает такие основные фазы процесса разработки:
1. Выработка концепции (Envisioning)
2. Планирование (Planning)
3. Разработка (Developing)
4. Стабилизация (Stabilizing)
5. Внедрение (Deploying)
Формирование команды
Модель команды проекта MSF не предусматривает формирования какой-либо специальной организационной структуры или введения специальных должностей. Все работы выполняются представителями соответствующих ролевых кластеров.
Состав команды определяется теми целями, которые необходимо достичь для успеха проекта: за достижение конкретной цели отвечает соответствующий ролевой кластер, а за успешность проекта в целом несет ответственность вся команда. В соответствии с целями проекта MSF выделяет шесть ролевых кластеров:
1. Управление продуктом: (роль в кластере - бизнес-аналитик)
Цель: Удовлетворение Заказчиков.
2. Управление программой: (роль в кластере - менеджер проекта)
Цель: Достижение результата в рамках проектных ограничений
3. Разработка: (роль в кластере - разработчик)
Цель: Создание продукта в соответствии со спецификацией
4. Тестирование: (роль в кластере - тестер)
Цель: Одобрение выпуска продукта только лишь после того, как все дефекты выявлены и улажены
5. Удовлетворение потребителя: (роль в кластере - бизнес-аналитик)
Цель: Повышение эффективности пользователя, увеличение потребительской ценности продукта
6. Управление выпуском: (роль в кластере - релиз-менеджер)
Цель: Беспроблемное внедрение и сопровождение продукта
Можно выделить три направления, в которых осуществляется масштабирование проектной команды.
1. Создание групп направлений. Группы направлений - это компактные мини-команды, отвечающие за определенные компоненты создаваемого решения и образующие матричную организационную структуру. В них входят по одному или несколько членов из разных ролевых кластеров. 
2. Создание функциональных групп. Функциональные группы - это группы, существующие внутри ролевых кластеров. Они создаются в больших проектах, когда необходимо сгруппировать работников внутри ролевых кластеров по их областям компетенции. 
3. Объединение ролей. Зачастую в малых проектных группах члены группы могут объединять роли. При этом MSF рекомендует соблюдать два принципа: 
Во-первых, роль команды разработчиков не может быть объединена ни с какой другой ролью. 
Во-вторых, избежание сочетания ролей, имеющих предопределенные 
конфликты интересов.
Фаза внедрения
Цель фазы - установка и отладка системы в реальных условиях эксплуатации, стабилизация внедренного решения, передача системы персоналу поддержки и сопровождения, получение окончательного одобрения результатов проекта со стороны Заказчика.
Результатами этой фазы являются:
· информационные системы эксплуатации и поддержки;
· работающие процедуры и процессы;
· базы знаний, отчеты, журналы протоколов;
· версии проектных документов, массивы данных и программный код, разработанные во время проекта;
· отчет о завершении проекта;
· окончательные версии всех проектных документов;
· показатели удовлетворенности Заказчика и потребителей.
2. Язык SQL. Предложения SQL: CREATE, DROP
SQL (structured query language — «язык структурированных запросов») — декларативный язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.

Изначально SQL был основным способом работы пользователя с базой данных и позволял выполнять следующий набор операций:
	•	создание в базе данных новой таблицы;
	•	добавление в таблицу новых записей;
	•	изменение записей;
	•	удаление записей;
	•	выборка записей из одной или нескольких таблиц (в соответствии с заданным условием);
	•	изменение структур таблиц.
	•	
«Программа» на языке SQL представляет собой простую линейную последовательность операторов языка SQL. Язык SQL в своем «чистом» виде операторов управления порядком выполнения запросов к БД (типа циклов, ветвлений, переходов) не имеет.
в язык SQL в качестве составных частей входят:
	•	язык манипулирования данными (Data Manipulation Language, DML)
	•	язык определения данных (Data Definition Language, DDL)
	•	язык управления данными (Data Control Language, DCL).
Подчеркнем, что это не отдельные языки, а различные команды одного языка. Такое деление проведено только лишь с точки зрения различного функционального назначения этих команд.

Предложения SQL: CREATE, DROP, DELETE, UPDATE
CREATE (от англ. create - создать) — DDL оператор языка SQL, используемый для создания объектов базы данных. В различных СУБД может использоваться для создания различных объектов, например таблиц, схем, представлений
	•	CREATE DATABASE (создать базу данных)
	•	CREATE TABLE (создать таблицу)
	•	CREATE VIEW (создать виртуальную таблицу)
	•	CREATE INDEX (создать индекс)
	•	CREATE TRIGGER (создать триггер)
	•	CREATE PROCEDURE (создать сохраненную процедуру)
DROP - DDL оператор языка SQL, используемый для удаления объектов базы данных. Удаляет одно или больше определений таблиц и все данные, индексы, триггеры, ограничения и разрешения для этих таблиц.
	•	DROP DATABASE (удалить базу данных)
	•	DROP TABLE (удалить таблицу)
	•	DROP VIEW (удалить виртуальную таблицу)
	•	DROP INDEX (удалить индекс)
	•	DROP TRIGGER (удалить триггер)
	•	DROP PROCEDURE (удалить сохраненную процедуру)
DELETE - DML-операция удаления записей из таблицы. Критерий отбора записей для удаления определяется выражением where. В случае, если критерий отбора не определён, выполняется удаление всех записей.
	•	DELETE FROM <имя таблицы > WHERE <предикат>]
UPDATE — оператор языка SQL, позволяющий обновить значения в заданных столбцах таблицы.
	•	UPDATE books SET price = 0 WHERE quantity = 0

3. Разработка пользовательских классов и объектов. Определить пользовательский класс. Определить в классе конструкторы без параметров
#include <stdio.h>
#include <iostream>
using namespace std;
class student //Пользовательский класс
{
public:
int course;
int age;
student() { //Конструктор без параметров
course = 1;
age = 18;
}
student(int course, int age) { //Конструктор с параметрами
this->course = course;
this->age = age;
}
student(const student &obj) { //Конструктор копирования
this->course = obj.course;
this->age = obj.age;
}
~student() { //Деструктор
std::cout<<"\nДеcтруктор сработал!\n";
}
int getAge() { //Геттер (селектор) возраста
return age;
}
void setAge(int age){ //Сеттер (модификатор) возраста
this->age = age;
}
int getCourse(){
return course;
}
void setCourse(int course){
this->course = course;
}
};

int main() {
student s1;
student s2(2,20);
student s3(s2);
s1.setAge(21);
s1.setCourse(5);
cout << s1.getAge() << " " << s1.getCourse()<< endl;
cout << s2.getAge() << " " << s2.getCourse()<< endl;
cout << s3.getAge() << " " << s3.getCourse()<< endl;
return 0;
}

билет 11
1. Понятие ООП. Основные принципы: инкапсуляция. 
(ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования
При объектно-ориентированном подходе к программированию программа представляет собой совокупность взаимодействующих между собой данных — объектов. Функциональную возможность и структуру объектов задают классы — типы данных, определенные пользователем. При рассмотрении объектов выделяется то, что объекты принадлежат одному или нескольким классам, которые определяют поведение (являются моделью) объекта. классы могут задавать поля .
Поля класса являются переменными, объявленными внутри класса. Они предназначены для хранения данных во время работы экземпляра класса (объекта). В описании класса поля должны предшествовать методам и свойствам. Обычно поля используются для обеспечения выполнения операций внутри класса.
Для получения и передачи данных в классе применяются 
Свойства. Свойства представляют собой атрибуты, которые составляют индивидуальность объекта и помогают описать его. Так как свойство обеспечивает обмен данными с внешней средой, то для доступа к его значению используются специальные Методы класса. Поэтому обычно свойство определяется тремя элементами: полем и двумя методами, которые осуществляют его чтение/запись
ООП основано на «трех китах» - трех важнейших принципах, придающих объектам новые свойства. Этими принципами являются инкапсуляция, наследование и полиморфизм.
Инкапсуляция есть объединение в единое целое данных и алгоритмов обработки этих данных. “Инкапсуляция" можно расшифровать как "заключение в капсулу". Если проще - это "обеспечение безопасности" в Java. В каждой программе есть параметры, к которым нельзя давать доступ всем.Инкапсуляция позволяет в максимальной степени изолировать объект от внешнего окружения. Она существенно повышает надежность разрабатываемых программ, т.к. локализованные в объекте алгоритмы обмениваются с программой сравнительно небольшими объемами данных, причем количество и тип этих данных обычно тщательно контролируются. В результате замена или модификация алгоритмов и данных, инкапсулированных в объект, как правило, не влечет за собой плохо прослеживаемых последствий для программы в целом. 
Управление доступом. Принцип инкапсуляции обеспечивается вводом в класс областей доступа:
 — private — закрытый, доступный только собственным методам;
 — public — открытый, доступный любым функциям; 
— protected — защищенный, доступный только собственным методам и методам производных классов. 
Члены класса, находящиеся в закрытой области (private), недоступны для использования со стороны внешнего кода. Пользователь не может использовать закрытые данные и методы.Напротив, члены класса, находящиеся в открытой секции (public), доступны для использования со стороны внешнего кода. Пользователь может взаимодействовать с объектом только через интерфейс. При описании класса каждый член класса помещается в одну из перечисленных выше областей доступа
Статические компоненты класса. Члены класса могут быть объявлены с использованием модификатора класса памяти static. Такие члены данных разделяются всеми экземплярами данного класса и хранятся в одном месте. Нестатические члены данных создаются для каждой переменной-объекта класса. Отсутствие возможности объявлять статические члены класса привело бы к необходимости объявлять эти данные на глобальном уровне программы. Это разорвало бы отношения между данными и их классом, а также не согласуется с основной парадигмой ООП – объединение в классе данных и методов для их обработки. Статический член позволяет данным класса, которые не специфичны для отдельного экземпляра, существовать в области видимости класса.
Инициализация объектов. При объявлении переменной, как правило, ее инициализируют.Кроме обычных методов в классах используются также и специальные методы, которые называются конструкторами. Конструкторы вызываются при создании нового объекта данного класса. Конструкторы выполняют инициализацию объекта. Конструктор определяет, как будет создаваться новый объект, когда это необходимо, может распределить под него память и инициализировать ее. Он может включать в себя код для распределения памяти, присваивание значений элементам, преобразование из одного типа в другой и многое полезное.
Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор без параметров.
2. Расстановка приоритетов исполнения проекта. Структурирование работ по этапам
Упорядоченный подход к сбору информации по проекту, необходимой для планирования, составления графика работ и контроля за выполнением проекта, обеспечивают пять типовых этапов, приводимых ниже.
	•	ЭТАП 1: разработка технического задания.
	•	ЭТАП 2: расстановка приоритетов.
	•	ЭТАП 3: структурирование работ по этапам.
	•	ЭТАП 4: совмещение структуры распределения работы по этапам (СРРПЭ) с организацией.
	•	ЭТАП 5: кодирование СРРПЭ для информационной системы.
Разработка технического задания на проект. Техническое задание - это определение конечного результата или цели вашего проекта - товара или услуги для вашего заказчика. Основной целью здесь является как можно более четкое определение промежуточных результатов работы для конечного пользователя и концентрация (в единое целое) планов проекта.
ТЗ должно разрабатываться под руководством управляющего проектом и клиента. Управляющий проектом должен согласовывать с заказчиком цели, промежуточные результаты работы на каждой стадии проекта, технические требования и т.д.
Техническое задание - это документ, который будет соответственно оформлен и использован владельцем проекта и участниками проекта для планирования и измерения успеха проекта. ТЗ объясняет, какую продукцию вы поставите своему клиенту по завершении проекта. ТЗ проекта должно представлять намеченные результаты в конкретном и поддающемся измерению виде.
ТЗ включает в себя:
1. Цели проекта.
2. Промежуточные результаты работы.
3. Контрольные точки.
4. Технические требования.
5. Ограничения и исключения.
6. Проверка выполнения работы совместно с клиентом.
Расстановка приоритетов
Одной из основных задач управляющего проектом является управление соотношением между временем, стоимостью и результативностью.
Матрица приоритетов проекта

Структурирование работ по этапам.
Работу над проектом можно разделить на более мелкие элементы.
Результат этого поэтапного процесса называется структурой распределения работы по этапам (СРРПЭ).
Этапы:
1. Проект – проект в целом.
2. Промежуточный результат – основные промежуточные результаты работы.
3. Предварительный результат – промежуточные результаты работы, на которые опираются остальные.
4. Элементарный результат – самый нижний уровень ответственности менеджеров.
5. Учет издержки – группировка работ в задании для отслеживания хода работ и учета ответственности.
6. Рабочее задание – отличаемые виды работ.
Каждый набор работ в СРРПЭ:
1. Определяет, какая работа будет выполняться (что).
2. Указывает время выполнения набора работ (как долго).
3. Определяет смету с учетом времени на выполнение набора работ (стоимость).
4. Определяет ресурсы, необходимые для выполнения набора работ (сколько).
5. Определяет контрольные пункты для измерения хода выполнения.
3. найдите количество стран в каждом континенте;

SELECT DISTINCT continent, count(name) 
FROM country 
GROUP BY continent
билет 12
1. Метод «сущность – связь». Основные понятия метода
Модель "сущность-связь" основывается на некой важной семантической информации о реальном мире и предназначена для логического представления данных. Определяет значения данных в контексте их взаимосвязи с другими данными. Из модели "сущность-связь" могут быть порождены все существующие модели данных (иерархическая, сетевая, реляционная, объектная).
Сущность представляет собой объект, информация о котором хранится в БД. Экземпляры сущности отличаются друг от друга и однозначно идентифицируются.
Названиями сущностей являются, как правило, существительные, например: ПРЕПОДАВАТЕЛЬ, ДИСЦИПЛИНА, КАФЕДРА, ГРУППА.

Атрибут - свойство сущности. Понятие аналогично понятию атрибута в отношении. Так, атрибутами сущности ПРЕПОДАВАТЕЛЬ могут быть Фамилия, Должность, Стаж.
Ключ сущности — атрибут или набор атрибутов, используемый для идентификации экземпляра сущности. Понятие ключа сущности аналогично понятию ключа отношения.
Степень связи является характеристикой связи между сущностями, которая может быть типа: 1:1,1: М, М:1, М: М.
Класс принадлежности сущности может быть: обязательным и необязательным. Класс принадлежности сущности является обязательным, если все экземпляры этой сущности обязательно участвуют в рассматриваемой связи, в противном случае -необязательным.
Пример 1. Связи типа 1:1; класс принадлежности обеих сущностей необязательный.
Каждый преподаватель ведет не более одной дисциплины, а каждая дисциплина ведется не более чем одним преподавателем; некоторые преподаватели не ведут ни одной дисциплины и имеются дисциплины, которые не ведет ни один из преподавателей.
Пример 2. Связи типа 1:1, класс принадлежности обеих сущностей обязательный.
Каждый преподаватель ведет одну дисциплину, и каждая дисциплина ведется одним преподавателем.
Пример 3. Связи типа 1: М. Каждый преподаватель может вести несколько дисциплин, но каждая дисциплина ведется одним преподавателем.
Пример 4. Связи типа М:1. Каждый преподаватель может вести одну дисциплину, но каждую дисциплину могут вести несколько преподавателей.
Пример 5. Связи типа 1: М вариант Н-О. Каждый преподаватель может вести несколько дисциплин или ни одной, но каждая дисциплина ведется одним преподавателем.
Пример 6. Связи типа М: М. Каждый преподаватель может вести несколько дисциплин, а каждая дисциплина может вестись несколькими преподавателями.
Пример 7. Связи типа М: М и вариант класса принадлежности О-Н. Допустим, что каждый преподаватель ведет не менее одной дисциплины, а дисциплина может вестись более чем одним преподавателем, есть и такие дисциплины, которые никто не ведет.
 
2. Формирование команды. Стадия Внедрения
MSF(Microsoft Solutions Framework) – методология разработки программного обеспечения от компании Microsoft, опирающаяся на практический опыт компании и описывающая управление людьми и управление процессами в ходе разработки решения.
Методология MSF состоит из принципов, моделей и дисциплин по управлению персоналом, процессами.
Модель процессов включает такие основные фазы процесса разработки:
1. Выработка концепции (Envisioning)
2. Планирование (Planning)
3. Разработка (Developing)
4. Стабилизация (Stabilizing)
5. Внедрение (Deploying)
Формирование команды
Модель команды проекта MSF не предусматривает формирования какой-либо специальной организационной структуры или введения специальных должностей. Все работы выполняются представителями соответствующих ролевых кластеров.
Состав команды определяется теми целями, которые необходимо достичь для успеха проекта: за достижение конкретной цели отвечает соответствующий ролевой кластер, а за успешность проекта в целом несет ответственность вся команда. В соответствии с целями проекта MSF выделяет шесть ролевых кластеров:
1. Управление продуктом: (роль в кластере - бизнес-аналитик)
Цель: Удовлетворение Заказчиков.
2. Управление программой: (роль в кластере - менеджер проекта)
Цель: Достижение результата в рамках проектных ограничений
3. Разработка: (роль в кластере - разработчик)
Цель: Создание продукта в соответствии со спецификацией
4. Тестирование: (роль в кластере - тестер)
Цель: Одобрение выпуска продукта только лишь после того, как все дефекты выявлены и улажены
5. Удовлетворение потребителя: (роль в кластере - бизнес-аналитик)
Цель: Повышение эффективности пользователя, увеличение потребительской ценности продукта
6. Управление выпуском: (роль в кластере - релиз-менеджер)
Цель: Беспроблемное внедрение и сопровождение продукта
Можно выделить три направления, в которых осуществляется масштабирование проектной команды.
1. Создание групп направлений. Группы направлений - это компактные мини-команды, отвечающие за определенные компоненты создаваемого решения и образующие матричную организационную структуру. В них входят по одному или несколько членов из разных ролевых кластеров. 
2. Создание функциональных групп. Функциональные группы - это группы, существующие внутри ролевых кластеров. Они создаются в больших проектах, когда необходимо сгруппировать работников внутри ролевых кластеров по их областям компетенции. 
3. Объединение ролей. Зачастую в малых проектных группах члены группы могут объединять роли. При этом MSF рекомендует соблюдать два принципа: 
Во-первых, роль команды разработчиков не может быть объединена ни с какой другой ролью. 
Во-вторых, избежание сочетания ролей, имеющих предопределенные 
конфликты интересов.
Фаза внедрения
Цель фазы - установка и отладка системы в реальных условиях эксплуатации, стабилизация внедренного решения, передача системы персоналу поддержки и сопровождения, получение окончательного одобрения результатов проекта со стороны Заказчика.
Результатами этой фазы являются:
· информационные системы эксплуатации и поддержки;
· работающие процедуры и процессы;
· базы знаний, отчеты, журналы протоколов;
· версии проектных документов, массивы данных и программный код, разработанные во время проекта;
· отчет о завершении проекта;
· окончательные версии всех проектных документов;
· показатели удовлетворенности Заказчика и потребителей.

3. Проектирование иерархии классов. Определить абстрактный класс. Определить иерархию классов, в основе которой будет находиться абстрактный класс
#include <iostream>
using namespace std;
class Figure // абстрактный класс Фигура
{
public:
// виртуальные функции
virtual double getSquare() =0;
virtual double getPerimeter() =0;
};

class Rectangle : public Figure // класс Прямоугольник, унаследованный от класса Фигура
{
private:
double width;
double height;
public:
Rectangle(double w, double h) : width(w), height(h) { } // конструктор
double getSquare() override // переопределение функции площади
{
return width * height;
}
double getPerimeter() override // переопределение функции периметра
{
return width * 2 + height * 2;
}
};

class Circle : public Figure // класс Окружность, унаследованный от класса Фигура
{
private:
double radius;
public:
Circle(double r) : radius(r) { } // конструктор класса
double getSquare() override // переопределение функции площади
{
return radius * radius * 3.14;
}
double getPerimeter() override // переопределение функции периметра
{
return 2 * 3.14 * radius;
}
};

int main() {
Rectangle rect(30, 50);
Circle circle(30);
cout << "Rectangle square: " << rect.getSquare() << endl;
cout << "Rectangle perimeter: " << rect.getPerimeter() << endl;
cout << "Circle square: " << circle.getSquare() << endl;
cout << "Circle perimeter: " << circle.getPerimeter() << endl;
return 0;
}

билет 13
1. Оператор SQL– SELECT (выборка). Предложения FROM, WHERE
SELECT – оператор запроса, возвращающий набор данных из базы данных.

SELECT [DISTINCT | ALL] <выражение для столбца | *> AS <псевдоним>э
FROM <имя таблицы> AS <псевдоним>
WHERE <предикат>
GROUP BY <список столбцов>
HAVING <условие на агрегатные значения>
ORDER BY <список столбцов>

Выборка может содержать дубликаты строк. Если требуется получить уникальные строки, то можно использовать ключевое слово DISTINCT или ALL для всех строк (по умолчанию).
Предложение WHERE <предикат> реализует горизонтальную выборку. При этом в результирующий набор попадут только те строки из источника записей, для каждой из которых значение предиката равно TRUE.
Агрегатные функции
COUNT(*)
Возвращает количество строк источника записей.
COUNT(<имя поля>)
Возвращает количество значений в указанном столбце.
SUM(<имя поля>) 
Возвращает сумму значений в указанном столбце.
AVG(<имя поля>)
Возвращает среднее значение в указанном столбце.
MIN(<имя поля>)
Возвращает минимальное значение в указанном столбце.
MAX(<имя поля>) 
Возвращает максимальное значение в указанном столбце.

Предложение GROUP BY используется для объединения результатов выборки по одному или нескольким столбцам.
Если запрос не содержит предложения GROUP BY, то агрегатные функции, включенные в предложение SELECT, исполняются над всеми результирующими строками запроса. Если запрос содержит предложение GROUP BY, каждый набор строк, который имеет одинаковые значения столбца или группы столбцов, заданных в предложении GROUP BY, составляет группу, и агрегатные функции выполняются для каждой группы отдельно.

Предложение HAVING применяется для фильтрации группировки (для проверки значений, которые получены с помощью агрегатной функции не из отдельных строк источника записей, определенного в предложении FROM, а из групп таких строк).
SELECT model, COUNT(model), AVG(price) 
FROM PC 
GROUP BY model 
HAVING AVG(price) < 800;

Чтобы упорядочить строки выборки, можно выполнить сортировку по любому количеству полей, указанных в предложении SELECT. Для этого используется предложение ORDER BY <список полей>, являющееся всегда последним предложением в операторе SELECT. При этом в списке полей могут указываться как имена полей, так и их порядковые позиции в списке предложения SELECT.

SELECT DISTINCT speed, ram 
FROM Pc 
ORDER BY ram 
DESC
Сортировку можно проводить по возрастанию (параметр ASC принимается по умолчанию) или по убыванию (параметр DESC).
2. Стадия Разработки. Стадия Стабилизации
Microsoft Solutions Framework (MSF) -методология разработки программного обеспечения, предложенная корпорацией Microsoft. MSF опирается на практический опыт Microsoft и описывает управление людьми и рабочими процессами в процессе разработки решения.
MSF представляет собой согласованный набор концепций, моделей и правил.
Модель процессов включает такие основные фазы процесса разработки:
· Выработка концепции (Envisioning)
· Планирование (Planning)
· Разработка (Developing)
· Стабилизация (Stabilizing)
· Внедрение (Deploying)
Фаза разработки
На фазе разработки проектная группа фокусируется на создании компонент решения (включая как документацию, так и программный код). Однако некоторая часть этой работы может продолжаться также на фазе стабилизации, если такая необходимость выявлена в процессе тестирования. Данная фаза также включает в себя разработку инфраструктуры.
Фаза стабилизации
Во время фазы стабилизации производится тестирование разработанного решения. При этом внимание фокусируется на его эксплуатации в реалистичной модели производственной среды. Проектная группа занимается приоритезацией и устранением ошибок, а также подготовкой решения к выпуску.
Обычно в начале фазы стабилизации скорость выявления ошибок командой тестирования превосходит скорость, с которой эти ошибки могут устраняться командой разработчиков. Невозможно предсказать, сколько ошибок будет найдено и как много времени понадобится на их устранение. Однако существует два статистических признака, помогающих проектной группе оценить уровень стабилизации решения. Это точка конвергенции (bug convergence) и точка достижения нуля ошибок (zero bug bounce).
Точка конвергенции – становится заметен существенный прогресс в устранении ошибок, то есть скорость устранения ошибок начинает превосходить скорость их обнаружения.
Точка достижения нуля ошибок – это момент, когда впервые все выявленные ошибки

3. Использование классов и алгоритмов стандартной библиотеки шаблонов. Создать контейнер из библиотеки STL.
	•	Последовательные контейнеры (vector, list, deque)
	•	Ассоциативные контейнеры (set, multiset, map, multimap)
	•	Контейнеры-адаптеры (stack, queue, priority_queue)







Пример создадим вектор в который добавим/изменим/удалим значения элементов и отсортируем его.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
vector <int> vec = {1, 2, 3, 4, 5}; // создадим контейнер вектор и заполним его

vec.push_back(9); // Вставим в конец вектора число 9
vec.pop_back(); // Удалим последний элемент вектора
vec.insert(vec.begin()+1,2,6); // Вставим после 1 элемента две шестерки
vec.erase(vec.begin()+1); // удалим 2 элемент
vec.at(0) = 7; // Изменим первый элемент на 7
for_each(vec.begin(), vec.end(), [] (int &n){ n++; }); //Применяет функцию for_each в которой мы все элементы вектора увеличиваем на 1
sort(vec.begin(), vec.end()); // Сортирует вектор по возрастанию
for(int i = 0; i<vec.size();i++) //выводим вектор на экран
cout << vec[i] << endl;
return 0;
}

билет 14
1. Расстановка приоритетов исполнения проекта. Структурирование работ по этапам
Упорядоченный подход к сбору информации по проекту, необходимой для планирования, составления графика работ и контроля за выполнением проекта, обеспечивают пять типовых этапов, приводимых ниже.
	•	ЭТАП 1: разработка технического задания.
	•	ЭТАП 2: расстановка приоритетов.
	•	ЭТАП 3: структурирование работ по этапам.
	•	ЭТАП 4: совмещение структуры распределения работы по этапам (СРРПЭ) с организацией.
	•	ЭТАП 5: кодирование СРРПЭ для информационной системы.
Разработка технического задания на проект. Техническое задание - это определение конечного результата или цели вашего проекта - товара или услуги для вашего заказчика. Основной целью здесь является как можно более четкое определение промежуточных результатов работы для конечного пользователя и концентрация (в единое целое) планов проекта.
ТЗ должно разрабатываться под руководством управляющего проектом и клиента. Управляющий проектом должен согласовывать с заказчиком цели, промежуточные результаты работы на каждой стадии проекта, технические требования и т.д.
Техническое задание - это документ, который будет соответственно оформлен и использован владельцем проекта и участниками проекта для планирования и измерения успеха проекта. ТЗ объясняет, какую продукцию вы поставите своему клиенту по завершении проекта. ТЗ проекта должно представлять намеченные результаты в конкретном и поддающемся измерению виде.
ТЗ включает в себя:
1. Цели проекта.
2. Промежуточные результаты работы.
3. Контрольные точки.
4. Технические требования.
5. Ограничения и исключения.
6. Проверка выполнения работы совместно с клиентом.
Расстановка приоритетов
Одной из основных задач управляющего проектом является управление соотношением между временем, стоимостью и результативностью.
Матрица приоритетов проекта

Структурирование работ по этапам.
Работу над проектом можно разделить на более мелкие элементы.
Результат этого поэтапного процесса называется структурой распределения работы по этапам (СРРПЭ).
Этапы:
1. Проект – проект в целом.
2. Промежуточный результат – основные промежуточные результаты работы.
3. Предварительный результат – промежуточные результаты работы, на которые опираются остальные.
4. Элементарный результат – самый нижний уровень ответственности менеджеров.
5. Учет издержки – группировка работ в задании для отслеживания хода работ и учета ответственности.
6. Рабочее задание – отличаемые виды работ.
Каждый набор работ в СРРПЭ:
1. Определяет, какая работа будет выполняться (что).
2. Указывает время выполнения набора работ (как долго).
3. Определяет смету с учетом времени на выполнение набора работ (стоимость).
4. Определяет ресурсы, необходимые для выполнения набора работ (сколько).
5. Определяет контрольные пункты для измерения хода выполнения.

2. Язык SQL. Предложения SQL: CREATE, DROP
SQL (structured query language — «язык структурированных запросов») — декларативный язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.

Изначально SQL был основным способом работы пользователя с базой данных и позволял выполнять следующий набор операций:
	•	создание в базе данных новой таблицы;
	•	добавление в таблицу новых записей;
	•	изменение записей;
	•	удаление записей;
	•	выборка записей из одной или нескольких таблиц (в соответствии с заданным условием);
	•	изменение структур таблиц.
	•	
«Программа» на языке SQL представляет собой простую линейную последовательность операторов языка SQL. Язык SQL в своем «чистом» виде операторов управления порядком выполнения запросов к БД (типа циклов, ветвлений, переходов) не имеет.
в язык SQL в качестве составных частей входят:
	•	язык манипулирования данными (Data Manipulation Language, DML)
	•	язык определения данных (Data Definition Language, DDL)
	•	язык управления данными (Data Control Language, DCL).
Подчеркнем, что это не отдельные языки, а различные команды одного языка. Такое деление проведено только лишь с точки зрения различного функционального назначения этих команд.

Предложения SQL: CREATE, DROP, DELETE, UPDATE
CREATE (от англ. create - создать) — DDL оператор языка SQL, используемый для создания объектов базы данных. В различных СУБД может использоваться для создания различных объектов, например таблиц, схем, представлений
	•	CREATE DATABASE (создать базу данных)
	•	CREATE TABLE (создать таблицу)
	•	CREATE VIEW (создать виртуальную таблицу)
	•	CREATE INDEX (создать индекс)
	•	CREATE TRIGGER (создать триггер)
	•	CREATE PROCEDURE (создать сохраненную процедуру)
DROP - DDL оператор языка SQL, используемый для удаления объектов базы данных. Удаляет одно или больше определений таблиц и все данные, индексы, триггеры, ограничения и разрешения для этих таблиц.
	•	DROP DATABASE (удалить базу данных)
	•	DROP TABLE (удалить таблицу)
	•	DROP VIEW (удалить виртуальную таблицу)
	•	DROP INDEX (удалить индекс)
	•	DROP TRIGGER (удалить триггер)
	•	DROP PROCEDURE (удалить сохраненную процедуру)
DELETE - DML-операция удаления записей из таблицы. Критерий отбора записей для удаления определяется выражением where. В случае, если критерий отбора не определён, выполняется удаление всех записей.
	•	DELETE FROM <имя таблицы > WHERE <предикат>]
UPDATE — оператор языка SQL, позволяющий обновить значения в заданных столбцах таблицы.
	•	UPDATE books SET price = 0 WHERE quantity = 0
	•	
3. Разработка пользовательских классов и объектов. Определить пользовательский класс.
#include <stdio.h>
#include <iostream>
using namespace std;
class student
{
public:
int course;
int age;
student() {
course = 1;
age = 18;
}
student(int course, int age) {
this->course = course;
this->age = age;
}
student(const student &obj) {
this->course = obj.course;
this->age = obj.age;
}
~student() {
std::cout<<"\nДеcтруктор сработал!\n";
}
int getAge() {
return age;
}
void setAge(int age){
this->age = age;
}
int getCourse(){
return course;
}
void setCourse(int course){
this->course = course;
}
};

int main() {
student s1;
student s2(2,20);
student s3(s2);
s1.setAge(21);
s1.setCourse(5);
cout << s1.getAge() << " " << s1.getCourse()<< endl;
cout << s2.getAge() << " " << s2.getCourse()<< endl;
cout << s3.getAge() << " " << s3.getCourse()<< endl;
return 0;
}
