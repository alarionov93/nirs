Слайд 1:
Здравствуйте, уважаемая комиссия.
Я хочу представить вам свою выпускную квалификационную работу на тему "Разработка аппаратного и программного обеспечения системы управления исполнительными механизмами андроидного робота."

Data 1:

Слайд 2:
Как известно, разработка андроидных роботов является на сегодняшний день актуальной задачей. В условиях развития информационных ресурсов одним из ключевых направлений современной компьютерной науки является разработка роботов. Процесс решения данных прикладных задач подразумевает, как правило, использование современных методов построения такого рода систем. Управление исполнительными механизмами современного роботизированного комплекса невозможно без применения методов искусственного интеллекта. К таким методам относятся: теория автоматов, нечеткая логика, встраиваемые системы, прикладная лингвистика.

Data 2: 
Цель задачи из текста

Слайд 4:
В основе робота было использовано уже имеющееся шасси, представляющее из себя набор исполнительных механизмов и датчиков перечень которых приведен в таблице на слайде. Описать таблицу.

Data 4:
Таблица "исходные данные"

...

Слайд 5:
Для удовлетворения требований было необходимо внести изменения в конструкцию, которые представлены на слайде.
В частности, были произведены изменения:
1. Добавлена БИНС. Для обеспечения управления курсом, траекторией и скоростью был установлен гироскоп, и написано ПО для осуществления регулирования вышеперечисленных параметров (ПИД-регулятор). Измеряется вращение вокруг оси Z, и согласно полученным результатам, выставляется значение заполнения ШИМ-сигнала подаваемого на драйвера левого и правого двигателей.
2. Серво-приводы и дисплей - для расширения возможностей эмоционального взаимодействия с человеком.
3. Новые датчики расстояния имеют больший диапазон работы, чем установленные ранее, и служат для навигации робота в помещении.
4. Блок реле управляет цепями нагрузок, 12 и 5 V. Есть постоянные и коммутируемые цепи.

Data 5: "Для удовлетворения требований, предъявляемых к роботу, в конструкцию добавлены следующие элементы:
1. БИНС. Необходима для стабилизации курса робота.
2. Серво-привод наклона головы. Нужен для расширения возможностей эмоционального взаимодействия с человеком.
3. Серво-приводы кистей рук. Также необходимы для расширения возможностей эмоционального взаимодействия с человеком.
4. Дисплей. Служит также для расширения возможностей эмоционального взаимодействия с человеком.
5. Датчики расстояния. Должны быть заменены для соответствия заявленным требованиям по ориентированию робота.
6. Реле. Должны быть использованы для корректного управления цепями нагрузки."

Слайд 6:
На слайде представлена общая структурная схема андроидного робота. Как можно видеть из этой схемы, робот состоит из модулей, (показать) связанных между собой различными интерфейсами связи, такими как: I2C (связь гироскопа и МК), RS485, UART, USB, HDMI и т.д..

Data 6:
[[Структурная_схема_робота.png]]

Слайд 7:
Исходя из структурной схемы, была разработана принципиальная схема робота, которая показана на слайде.
В схеме показаны такие элементы, как:

Data 7:
[[Принципиальная_схема_робота.png]]

Слайд 8:
Управление двигателями происходит с помощью микросхем VNH5019A.
В качестве приводов рук и ног используются электродвигатели постоянного тока от сткелоподъемников автомобиля ВАЗ 2110. Эти двигатели обладают большим крутящим моментом, достаточным для поворота рук и перемещения робота. Скорость вращения двигателей может изменяться под действием ШИМ-сигнала. Направление вращения задается полярностью подключения. Таким образом, для управления этим двигателем идеально подходит плата VNH5019A. Это сдвоенный мостовой драйвер, предназначенный для управления электродвигателями постоянного тока. ИМС имеет возможность управления выходными цепями с помощью ШИМ-сигнала. Схема включения – типовая, взята из официальной документации.
Одна микросхема VNH5019A предоставляет два независимых «мостовых» выхода или четыре обычных силовых выхода нагрузочной способностью до 30 ампер при напряжении до 50 вольт. Это больше, чем требуется, и опыту практического применения этой микросхемы сказать, что она выдерживает токи до 30 ампер на канал без каких-либо последствий при наличии качественного охлаждения. В схеме блока применены две такие микросхемы; таким образом, число силовых выходов может варьироваться от четырех до восьми.
Каждый из мостовых выходов VNH5019A имеет возможность измерения величины проходящего через него постоянного тока за счет наличия вывода ― Current sensing A/B‖. Технически это общая точка драйверов обоих полумостов канала, (можно нарисовать схему), которая должна подключаться к общему проводу силового питания через токовый шунт или напрямую, если измерение тока не требуется.

Data 8:
[[Внешний_вид_VNH5019A.jpg]]

Слайд 9:
На этом слайде показаны двигатели внутри корпуса робота.

Data 9:
[[Двигатели_установленные_в_робота.png]]

Слайд 10:
Работа рук регулируется конечным автоматом. Он имеет 9 состояний, с условными переходами между ними. Безусловный переход выполняется из начального состояния. Когда робот включился, он опускает обе руки

Data 10:
[[Автомат_рук.png]]

Слайд 11:
Работа рук регулируется конечным автоматом. Он имеет 9 состояний, с условными переходами между ними. Безусловный переход выполняется из начального состояния. Когда робот включился, он опускает обе руки. (Автомат в граф материалах)На этом слайде показан код автомата управления руками робота. Как можно видеть, для обеспечения ограничения поворота моторов рук было необходимо использовать концевые выключатели, вводить дополнительные состояния автомата и выполнять проверку прошлой команды. Это происходит потому, что когда выключатель нажат, (допустим, рука вверху) рука не может двигаться, кроме случая, когда следующая команда была "вниз". По этой же причине необходимо было ввести дополнительно 2 состояния (begin_spin_down и begin_spin_up) (К.В. нажат и рука не может двигаться). В противном случае не представилось бы возможности ограничить движение рук, что негативно сказалось бы на целостности, ремонтопригодности и долговечности конструкции робота.


Data 11:
void rigthHandWork()
{
	switch (RH_State)
	{
		case HAND_STATE_INIT: // 0
			hands_pwm = 0;
			RH_Time = 0;
			RH_State = HAND_STATE_GO_DOWN;
			break;
		case HAND_STATE_GO_DOWN: // 1
			hands_pwm = HANDS_PWM_DN;
			old_RH_Command = RIGHTHANDDOWN;
			RH_GO_DOWN();
			if (RH_LIMIT || (++RH_Time > 1000)) RH_State = HAND_STATE_STOP;
			break;
		...
		case HAND_STATE_IDLE: // 8
			if ((RH_IS_NEW_CMD) & (RH_Command == RIGHTHANDUP))
			{
				RH_State = HAND_STATE_BEGIN_SPIN_UP;
				RH_Time = 0;
				old_RH_Command = RH_Command;
			}
			if ((RH_IS_NEW_CMD) & (RH_Command == RIGHTHANDDOWN))
			{
				RH_State = HAND_STATE_BEGIN_SPIN_DOWN;
				RH_Time = 0;
				old_RH_Command = RH_Command;
			}
			break;
	}
	old_RH_State = RH_State;
}

Слайд 12:
На этом слайде представлен главный цикл программы, который заключается в приёме команд от компьютера в виде байт, отправленных в последовательный порт, их разборе, и выполнения команды. Согласно протоколу обмена, первый байт отвечает за номер подсистемы, второй - за конкретную команду. Далее могут следовать параметры. Ответ МК имеет такой же формат. Описать подсистемы, к которым команды относятся.

Data 12:
[[Главный_цикл.png]]

Слайд 13:
На слайде представлен алгоритм генерации текста.
В первой части этого метода мы задаем генераторы. Далее, рассчитываем биграммы и триграммы (фактически, мы считаем количество одинаковых пар и троек слов в тексте). Далее, вычисляем вероятность слова в зависимости от двух предыдущих, помещая данное слово и его вероятность в словарь. Необходимо учесть, что текст должен быть сгенерирован на заданную тему. Для этого функция uni_not_rand добавляет из модели слова по следующему правилу: 
1) Попытаться получить из модели слова, которые могут следовать за словами, которые идут за токенами key1 и key2.
2) Если это не получится, выполнить функцию unirand, описанную выше. В этом случае в предложение добавится слово, наиболее вероятное в данном контексте.
3) Если на шаге 1 удается получить необходимые слова, то выбираем слово с максимальным весом из тех, которые надо вывести.
4) Для каждого w и freq (слово и его частота в корпусе) проверяем, не совпадает ли оно с требуемым.
5) Если совпадение найдено, то уменьшаем вес выведенного слова в 2 раза.
6) После этого возвращаем слово, которое было получено на предыдущем шаге.
После генерации каждого нового предложения выполняется сравнение слов, использованных в нем со словарем слов с вычисленными весами, для того, чтобы убедиться в соответствии темы предложения заданной.

Data 13:
[[Алгоритм_генерации_текста.png]]

Слайд 14:
На этом слайде представлен внешний вид робота. Как можно заметить,

Data 14:
[[Внешний_вид_робота.png]]

